#!/usr/bin/env bash

# MCP Server Selector v2.0
# Production-grade TUI for managing Claude Code MCP servers
# Cross-platform (Linux/macOS) - Never modifies global config

set -euo pipefail

# ============================================================================
# CONSTANTS & GLOBALS
# ============================================================================

readonly SCRIPT_NAME="$(basename "$0")"
readonly VERSION="2.1.0"

# Color codes
readonly COLOR_RESET='\033[0m'
readonly COLOR_RED='\033[0;31m'
readonly COLOR_GREEN='\033[0;32m'
readonly COLOR_YELLOW='\033[1;33m'
readonly COLOR_BLUE='\033[0;34m'
readonly COLOR_CYAN='\033[0;36m'
readonly COLOR_WHITE='\033[1m'

# Markers
readonly MARK_ERROR="✗"
readonly MARK_SUCCESS="✓"
readonly MARK_WARNING="⚠"
readonly MARK_INFO="→"

# State file (created in main, cleaned up via trap)
STATE_FILE=""

# Settings file path (determined during discovery)
SETTINGS_FILE_PATH=""
SETTINGS_SCOPE=""

# ============================================================================
# UTILITY FUNCTIONS
# ============================================================================

# Portable realpath implementation (works on Linux + macOS)
# Args: $1 - path to resolve
# Returns: absolute path
realpath_portable() {
    local path="$1"

    if [[ -d "$path" ]]; then
        (cd "$path" && pwd)
    elif [[ -e "$path" ]]; then
        local dir=$(dirname "$path")
        local base=$(basename "$path")
        (cd "$dir" && echo "$(pwd)/$base")
    else
        echo "$path"
    fi
}

# Detect operating system
# Returns: "Linux" or "Darwin" or "Unknown"
detect_os() {
    local os
    os=$(uname -s)
    echo "$os"
}

# Messaging utilities
msg_info() {
    echo -e "${COLOR_CYAN}${MARK_INFO}${COLOR_RESET} $*"
}

msg_success() {
    echo -e "${COLOR_GREEN}${MARK_SUCCESS}${COLOR_RESET} $*"
}

msg_error() {
    echo -e "${COLOR_RED}${MARK_ERROR}${COLOR_RESET} $*" >&2
}

msg_warning() {
    echo -e "${COLOR_YELLOW}${MARK_WARNING}${COLOR_RESET} $*"
}

msg_header() {
    echo -e "${COLOR_WHITE}${COLOR_CYAN}$*${COLOR_RESET}"
}

# ============================================================================
# DEPENDENCY CHECKING
# ============================================================================

# Check for required dependencies (fzf, jq)
# Exits with error if missing, provides OS-specific installation instructions
check_dependencies() {
    local missing_deps=()

    for cmd in fzf jq; do
        if ! command -v "$cmd" &> /dev/null; then
            missing_deps+=("$cmd")
        fi
    done

    if [[ ${#missing_deps[@]} -eq 0 ]]; then
        return 0
    fi

    msg_error "Missing required dependencies: ${missing_deps[*]}"
    echo ""

    local os
    os=$(detect_os)

    case "$os" in
        Linux)
            # Detect Linux package manager
            if command -v apt &> /dev/null; then
                echo -e "${COLOR_CYAN}Install with:${COLOR_RESET}"
                echo "  sudo apt update && sudo apt install ${missing_deps[*]}"
            elif command -v dnf &> /dev/null; then
                echo -e "${COLOR_CYAN}Install with:${COLOR_RESET}"
                echo "  sudo dnf install ${missing_deps[*]}"
            elif command -v yum &> /dev/null; then
                echo -e "${COLOR_CYAN}Install with:${COLOR_RESET}"
                echo "  sudo yum install ${missing_deps[*]}"
            elif command -v pacman &> /dev/null; then
                echo -e "${COLOR_CYAN}Install with:${COLOR_RESET}"
                echo "  sudo pacman -S ${missing_deps[*]}"
            else
                echo -e "${COLOR_CYAN}Install using your system's package manager${COLOR_RESET}"
            fi
            ;;
        Darwin)
            if command -v brew &> /dev/null; then
                echo -e "${COLOR_CYAN}Install with:${COLOR_RESET}"
                echo "  brew install ${missing_deps[*]}"
            else
                echo -e "${COLOR_CYAN}Install Homebrew first:${COLOR_RESET}"
                echo "  /bin/bash -c \"\$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)\""
                echo ""
                echo -e "${COLOR_CYAN}Then install dependencies:${COLOR_RESET}"
                echo "  brew install ${missing_deps[*]}"
            fi
            ;;
        *)
            echo -e "${COLOR_CYAN}Please install: ${missing_deps[*]}${COLOR_RESET}"
            ;;
    esac

    exit 1
}

# ============================================================================
# FORMAT DETECTION & PARSING
# ============================================================================

# Detect configuration file format
# Args: $1 - file path
# Returns: "mcp" or "settings" or "unknown"
detect_file_format() {
    local file="$1"

    if [[ ! -f "$file" ]]; then
        echo "unknown"
        return 1
    fi

    if ! jq empty "$file" 2>/dev/null; then
        echo "unknown"
        return 1
    fi

    # Check for mcpServers object
    if jq -e '.mcpServers' "$file" >/dev/null 2>&1; then
        echo "mcp"
        return 0
    fi

    # Check for enabledMcpjsonServers or disabledMcpjsonServers arrays
    if jq -e '.enabledMcpjsonServers' "$file" >/dev/null 2>&1 || \
       jq -e '.disabledMcpjsonServers' "$file" >/dev/null 2>&1; then
        echo "settings"
        return 0
    fi

    echo "unknown"
    return 1
}

# Get numeric priority for scope (for precedence resolution)
# Args: $1 - scope label (local/project/user)
# Returns: numeric priority (3=highest, 1=lowest)
get_scope_priority() {
    case "$1" in
        local) echo 3 ;;
        project) echo 2 ;;
        user) echo 1 ;;
        *) echo 0 ;;
    esac
}

# Parse settings file (extracts enable/disable arrays ONLY, not mcpServers definitions)
# Args: $1 - file path, $2 - scope label (local/project/user)
# Output: Lines in format "type:server:scope:file"
# Types: enable (server enabled), disable (server disabled)
# Example: enable:fetch:user:~/.claude/settings.json
parse_settings_file() {
    local file="$1"
    local scope="$2"

    if [[ ! -f "$file" ]] || ! jq empty "$file" 2>/dev/null; then
        return 0
    fi

    # Extract enabled servers
    local enabled
    enabled=$(jq -r '.enabledMcpjsonServers[]? // empty' "$file" 2>/dev/null | sort -u)

    # Extract disabled servers
    local disabled
    disabled=$(jq -r '.disabledMcpjsonServers[]? // empty' "$file" 2>/dev/null | sort -u)

    # Output enabled servers
    if [[ -n "$enabled" ]]; then
        while IFS= read -r server; do
            [[ -n "$server" ]] && echo "enable:$server:$scope:$file"
        done <<< "$enabled"
    fi

    # Output disabled servers
    if [[ -n "$disabled" ]]; then
        while IFS= read -r server; do
            [[ -n "$server" ]] && echo "disable:$server:$scope:$file"
        done <<< "$disabled"
    fi
}

# Parse .mcp.json file (mcpServers object format only, no enable/disable arrays)
# Args: $1 - file path, $2 - scope label (project only, not used for ~/.claude.json)
# Output: Lines in format "def:server:scope:file"
# Example: def:coingecko:project:./.mcp.json
parse_mcp_json_file() {
    local file="$1"
    local scope="$2"

    if [[ ! -f "$file" ]] || ! jq empty "$file" 2>/dev/null; then
        return 0
    fi

    # Extract server names from mcpServers object keys
    local servers
    servers=$(jq -r '.mcpServers | keys[]? // empty' "$file" 2>/dev/null | sort -u)

    if [[ -n "$servers" ]]; then
        while IFS= read -r server; do
            [[ -n "$server" ]] && echo "def:$server:$scope:$file"
        done <<< "$servers"
    fi
}

# Parse ~/.claude.json file (handles BOTH user and project-specific scopes)
# Args: $1 - file path (~/.claude.json)
# Output: Lines in format "type:server:scope:file"
# Types: def (server defined), enable (server enabled), disable (server disabled)
# Scopes: user (root .mcpServers), local (under .projects[cwd])
# Example: def:fetch:user:~/.claude.json
#          def:stripe:local:~/.claude.json
#          enable:time:local:~/.claude.json
parse_claude_json_file() {
    local file="$1"

    if [[ ! -f "$file" ]] || ! jq empty "$file" 2>/dev/null; then
        return 0
    fi

    # Get current working directory for project matching
    local cwd
    cwd=$(pwd)

    # Parse user-scope servers (root level .mcpServers)
    local user_servers
    user_servers=$(jq -r '.mcpServers | keys[]? // empty' "$file" 2>/dev/null | sort -u)

    if [[ -n "$user_servers" ]]; then
        while IFS= read -r server; do
            [[ -n "$server" ]] && echo "def:$server:user:$file"
        done <<< "$user_servers"
    fi

    # Parse local-scope servers (project-specific .projects[cwd].mcpServers)
    local local_servers
    local_servers=$(jq -r --arg cwd "$cwd" '.projects[$cwd].mcpServers | keys[]? // empty' "$file" 2>/dev/null | sort -u)

    if [[ -n "$local_servers" ]]; then
        while IFS= read -r server; do
            [[ -n "$server" ]] && echo "def:$server:local:$file"
        done <<< "$local_servers"
    fi

    # Parse local-scope enabled servers (.projects[cwd].enabledMcpjsonServers)
    local enabled
    enabled=$(jq -r --arg cwd "$cwd" '.projects[$cwd].enabledMcpjsonServers[]? // empty' "$file" 2>/dev/null | sort -u)

    if [[ -n "$enabled" ]]; then
        while IFS= read -r server; do
            [[ -n "$server" ]] && echo "enable:$server:local:$file"
        done <<< "$enabled"
    fi

    # Parse local-scope disabled servers (.projects[cwd].disabledMcpjsonServers)
    local disabled
    disabled=$(jq -r --arg cwd "$cwd" '.projects[$cwd].disabledMcpjsonServers[]? // empty' "$file" 2>/dev/null | sort -u)

    if [[ -n "$disabled" ]]; then
        while IFS= read -r server; do
            [[ -n "$server" ]] && echo "disable:$server:local:$file"
        done <<< "$disabled"
    fi
}

# ============================================================================
# CONFIGURATION DISCOVERY & NEW PROJECT FLOW
# ============================================================================

# Check for configuration and handle new project flow if needed
# No longer sets SETTINGS_FILE_PATH or SETTINGS_SCOPE (multi-source approach)
discover_settings_file() {
    local current_dir
    current_dir=$(pwd)

    # Check if any local config exists
    if [[ -f "$current_dir/.claude/settings.local.json" ]] || \
       [[ -f "$current_dir/.claude/settings.json" ]] || \
       [[ -f "$current_dir/.mcp.json" ]]; then
        # Local config exists, proceed normally
        return 0
    fi

    # No local config, check if global exists
    if [[ -f "$HOME/.claude/settings.json" ]] || \
       [[ -f "$HOME/.claude/settings.local.json" ]] || \
       [[ -f "$HOME/.claude.json" ]]; then
        # Global config exists, trigger new project flow
        handle_new_project_prompt
        return $?
    fi

    # No configuration found anywhere
    msg_error "No Claude configuration found (local or global)"
    echo ""
    echo "Please configure Claude first by running 'claude' once."
    exit 1
}

# Handle new project initialization flow
# Prompts user to create local config or use global
handle_new_project_prompt() {
    clear
    msg_header "New Project Detected"
    echo ""
    echo "You are in a directory without a local Claude configuration."
    echo "Global configuration will be used as a template."
    echo ""
    echo "What would you like to do?"
    echo ""
    echo "  ${COLOR_GREEN}1)${COLOR_RESET} Create local configuration (.claude/settings.local.json) for this project ${COLOR_CYAN}(Recommended)${COLOR_RESET}"
    echo "  ${COLOR_YELLOW}2)${COLOR_RESET} Continue with global settings only (changes will still be saved to local)"
    echo "  ${COLOR_RED}3)${COLOR_RESET} Abort"
    echo ""

    local choice
    read -rp "Enter your choice [1-3]: " choice

    case "$choice" in
        1)
            # Create local config from global template
            msg_info "Creating local configuration..."
            mkdir -p ./.claude

            # Find global settings file to use as template
            local template=""
            if [[ -f "$HOME/.claude/settings.json" ]]; then
                template="$HOME/.claude/settings.json"
            elif [[ -f "$HOME/.claude/settings.local.json" ]]; then
                template="$HOME/.claude/settings.local.json"
            elif [[ -f "$HOME/.claude.json" ]]; then
                template="$HOME/.claude.json"
            else
                # Create empty settings
                echo '{}' > "./.claude/settings.local.json"
                msg_success "Created empty ./.claude/settings.local.json"
                echo ""
                return 0
            fi

            cp "$template" "./.claude/settings.local.json"
            msg_success "Created ./.claude/settings.local.json from $template"
            echo ""
            return 0
            ;;
        2)
            # Continue without creating local config
            # Changes will still be saved to .claude/settings.local.json when user confirms
            msg_info "Continuing with global settings..."
            echo ""
            return 0
            ;;
        3|*)
            # Abort
            msg_warning "Operation cancelled"
            exit 0
            ;;
    esac
}

# ============================================================================
# STATE MANAGEMENT
# ============================================================================

# Discover and parse all configuration sources
# mcpServers definitions can ONLY exist in ~/.claude.json (user & local) and ./.mcp.json (project)
# Enable/disable arrays can exist in ~/.claude.json projects AND any settings file
# Output: Lines in format "state:server:scope:file" or "defined:server:scope:file"
discover_and_parse_all_sources() {
    local temp_raw
    temp_raw=$(mktemp)

    # Parse ~/.claude.json (handles both user-scope root AND local-scope project entries)
    # Also extracts enable/disable arrays from .projects[cwd]
    parse_claude_json_file "$HOME/.claude.json" >> "$temp_raw"

    # Parse ./.mcp.json (project-scope mcpServers only)
    parse_mcp_json_file "./.mcp.json" "project" >> "$temp_raw"

    # Parse enable/disable arrays from all settings files (reverse precedence order)
    # User scope (lowest priority)
    parse_settings_file "$HOME/.claude/settings.json" "user" >> "$temp_raw"
    parse_settings_file "$HOME/.claude/settings.local.json" "user" >> "$temp_raw"

    # Project scope
    parse_settings_file "./.claude/settings.json" "project" >> "$temp_raw"

    # Local scope (highest priority)
    parse_settings_file "./.claude/settings.local.json" "local" >> "$temp_raw"

    cat "$temp_raw"
    rm -f "$temp_raw"
}

# Load servers from all sources with DUAL precedence resolution
# Separates server definitions from enable/disable state
# State format: "state:server:def_scope:def_file" (one per line)
# Example: "on:fetch:project:./.claude/settings.json"
# Where state=on/off, def_scope/def_file=where server is DEFINED
load_servers() {
    local raw_data
    raw_data=$(discover_and_parse_all_sources)

    if [[ -z "$raw_data" ]]; then
        msg_warning "No MCP servers found in any configuration file"
        echo ""
        msg_info "You can add servers using Ctrl-A in the TUI"
        echo ""
        touch "$STATE_FILE"
        return 0
    fi

    # Build two separate maps for dual precedence resolution
    # Map 1: Server definitions (where server is configured)
    # Key: server_name, Value: priority:scope:file
    declare -A server_definitions

    # Map 2: Enable/disable state (whether server is active)
    # Key: server_name, Value: priority:state (on/off)
    declare -A server_states

    # Parse raw data and populate both maps
    while IFS=: read -r type server scope file; do
        [[ -z "$server" ]] && continue

        local priority
        priority=$(get_scope_priority "$scope")

        if [[ "$type" == "def" ]]; then
            # This is a server definition
            local new_value="$priority:$scope:$file"

            if [[ -n "${server_definitions[$server]:-}" ]]; then
                local existing_priority
                existing_priority=$(echo "${server_definitions[$server]}" | cut -d: -f1)

                # Higher priority wins (3 > 2 > 1)
                if [[ $priority -gt $existing_priority ]]; then
                    server_definitions[$server]="$new_value"
                fi
            else
                server_definitions[$server]="$new_value"
            fi

        elif [[ "$type" == "enable" ]]; then
            # This is an enable directive
            local new_value="$priority:on"

            if [[ -n "${server_states[$server]:-}" ]]; then
                local existing_priority
                existing_priority=$(echo "${server_states[$server]}" | cut -d: -f1)

                if [[ $priority -gt $existing_priority ]]; then
                    server_states[$server]="$new_value"
                fi
            else
                server_states[$server]="$new_value"
            fi

        elif [[ "$type" == "disable" ]]; then
            # This is a disable directive
            local new_value="$priority:off"

            if [[ -n "${server_states[$server]:-}" ]]; then
                local existing_priority
                existing_priority=$(echo "${server_states[$server]}" | cut -d: -f1)

                if [[ $priority -gt $existing_priority ]]; then
                    server_states[$server]="$new_value"
                fi
            else
                server_states[$server]="$new_value"
            fi
        fi
    done <<< "$raw_data"

    # Write to state file
    > "$STATE_FILE"  # Truncate

    # Merge: For each defined server, attach its state
    for server in "${!server_definitions[@]}"; do
        local def_value="${server_definitions[$server]}"
        # Extract scope:file from priority:scope:file
        local def_scope def_file
        def_scope=$(echo "$def_value" | cut -d: -f2)
        def_file=$(echo "$def_value" | cut -d: -f3-)

        # Get state (default to "on" if not mentioned in any enable/disable array)
        # Servers defined in mcpServers are enabled by default unless explicitly disabled
        local state="on"
        if [[ -n "${server_states[$server]:-}" ]]; then
            local state_value="${server_states[$server]}"
            state=$(echo "$state_value" | cut -d: -f2)
        fi

        echo "$state:$server:$def_scope:$def_file" >> "$STATE_FILE"
    done

    # Sort state file by server name
    sort -t: -k2 "$STATE_FILE" -o "$STATE_FILE"
}

# Toggle server state in state file
# Args: $1 - server name (may have prefix like "[ON ] server-name (scope)")
toggle_server() {
    local raw_input="$1"

    # Strip ANSI codes, prefixes, and scope suffix to get clean server name
    local server
    server=$(echo "$raw_input" | sed 's/\x1b\[[0-9;]*m//g' | sed 's/^\[ON \] *//' | sed 's/^\[OFF\] *//' | sed 's/^     *//' | sed 's/ *(.*)$//')

    # Read state file, toggle the server, write back (preserve scope and file)
    local temp_state
    temp_state=$(mktemp)

    while IFS=: read -r state srv scope file; do
        if [[ "$srv" == "$server" ]]; then
            # Toggle state, preserve scope and file
            if [[ "$state" == "on" ]]; then
                echo "off:$srv:$scope:$file" >> "$temp_state"
            else
                echo "on:$srv:$scope:$file" >> "$temp_state"
            fi
        else
            # Keep unchanged
            echo "$state:$srv:$scope:$file" >> "$temp_state"
        fi
    done < "$STATE_FILE"

    mv "$temp_state" "$STATE_FILE"
}

# Add new server to state file (disabled by default, local scope)
# Args: $1 - server name
add_server() {
    local server="$1"

    # Validate server name (alphanumeric, dashes, underscores)
    if [[ ! "$server" =~ ^[a-zA-Z0-9_-]+$ ]]; then
        msg_error "Invalid server name. Use only alphanumeric characters, dashes, and underscores."
        return 1
    fi

    # Check for duplicates (check column 2 for server name)
    if grep -q "^[^:]*:$server:" "$STATE_FILE" 2>/dev/null; then
        msg_warning "Server '$server' already exists"
        return 1
    fi

    # Add to state file (disabled, local scope, project-local settings file)
    echo "off:$server:local:./.claude/settings.local.json" >> "$STATE_FILE"
    sort -t: -k2 "$STATE_FILE" -o "$STATE_FILE"
}

# Remove server from state file
# Args: $1 - server name (may have prefix and scope suffix)
remove_server() {
    local raw_input="$1"

    # Strip ANSI codes, prefixes, and scope suffix
    local server
    server=$(echo "$raw_input" | sed 's/\x1b\[[0-9;]*m//g' | sed 's/^\[ON \] *//' | sed 's/^\[OFF\] *//' | sed 's/^     *//' | sed 's/ *(.*)$//')

    # Remove from state file (match server name in column 2)
    local temp_state
    temp_state=$(mktemp)

    while IFS=: read -r state srv scope file; do
        if [[ "$srv" != "$server" ]]; then
            echo "$state:$srv:$scope:$file" >> "$temp_state"
        fi
    done < "$STATE_FILE"

    mv "$temp_state" "$STATE_FILE"
}

# Enable all servers in state file (preserve scope and file metadata)
enable_all_servers() {
    local temp_state
    temp_state=$(mktemp)

    while IFS=: read -r state srv scope file; do
        echo "on:$srv:$scope:$file" >> "$temp_state"
    done < "$STATE_FILE"

    mv "$temp_state" "$STATE_FILE"
}

# Disable all servers in state file (preserve scope and file metadata)
disable_all_servers() {
    local temp_state
    temp_state=$(mktemp)

    while IFS=: read -r state srv scope file; do
        echo "off:$srv:$scope:$file" >> "$temp_state"
    done < "$STATE_FILE"

    mv "$temp_state" "$STATE_FILE"
}

# Save state file to project-local settings only (./.claude/settings.local.json)
# Never modifies global user settings
save_state_to_settings() {
    local target="./.claude/settings.local.json"

    # Create .claude directory if it doesn't exist
    if [[ ! -d "./.claude" ]]; then
        mkdir -p "./.claude"
        msg_info "Created .claude/ directory"
    fi

    # Parse state file into enabled and disabled arrays (server names only)
    local enabled_servers=()
    local disabled_servers=()

    while IFS=: read -r state server scope file; do
        [[ -z "$server" ]] && continue

        if [[ "$state" == "on" ]]; then
            enabled_servers+=("$server")
        elif [[ "$state" == "off" ]]; then
            disabled_servers+=("$server")
        fi
    done < "$STATE_FILE"

    # Build JSON arrays
    local enabled_json
    local disabled_json

    if [[ ${#enabled_servers[@]} -eq 0 ]]; then
        enabled_json="[]"
    else
        enabled_json=$(printf '%s\n' "${enabled_servers[@]}" | jq -R . | jq -s -c .)
    fi

    if [[ ${#disabled_servers[@]} -eq 0 ]]; then
        disabled_json="[]"
    else
        disabled_json=$(printf '%s\n' "${disabled_servers[@]}" | jq -R . | jq -s -c .)
    fi

    # Initialize with empty object if file doesn't exist
    if [[ ! -f "$target" ]]; then
        echo '{}' > "$target"
        msg_info "Created $target"
    fi

    # Atomic update using temp file (merge with existing settings)
    local temp_file
    temp_file=$(mktemp)

    jq --argjson enabled "$enabled_json" \
       --argjson disabled "$disabled_json" \
       '.enabledMcpjsonServers = $enabled | .disabledMcpjsonServers = $disabled' \
       "$target" > "$temp_file"

    mv "$temp_file" "$target"
}

# ============================================================================
# TUI GENERATION FUNCTIONS
# ============================================================================

# Generate fzf list from state file
# Output format: "[ON ] server-name (scope)" or "[OFF] server-name (scope)"
generate_fzf_list() {
    if [[ ! -f "$STATE_FILE" ]] || [[ ! -s "$STATE_FILE" ]]; then
        echo ""
        return
    fi

    local dim='\033[2m'  # Dim/grey color for scope labels

    while IFS=: read -r state server scope file; do
        [[ -z "$server" ]] && continue

        if [[ "$state" == "on" ]]; then
            echo -e "${COLOR_GREEN}[ON ]${COLOR_RESET} $server ${dim}($scope)${COLOR_RESET}"
        elif [[ "$state" == "off" ]]; then
            echo -e "${COLOR_RED}[OFF]${COLOR_RESET} $server ${dim}($scope)${COLOR_RESET}"
        fi
    done < "$STATE_FILE"
}

# Generate preview for selected server
# Args: $1 - full line from fzf (e.g., "[ON ] server-name (scope)")
generate_preview() {
    local raw_input="$1"

    # Strip ANSI codes, prefixes, and scope suffix
    local server
    server=$(echo "$raw_input" | sed 's/\x1b\[[0-9;]*m//g' | sed 's/^\[ON \] *//' | sed 's/^\[OFF\] *//' | sed 's/^     *//' | sed 's/ *(.*)$//')

    if [[ -z "$server" ]]; then
        echo "No server selected"
        return
    fi

    # Find effective state and definition source from state file
    local current_state=""
    local def_scope=""
    local def_file=""

    while IFS=: read -r state srv scope file; do
        if [[ "$srv" == "$server" ]]; then
            current_state="$state"
            def_scope="$scope"
            def_file="$file"
            break
        fi
    done < "$STATE_FILE"

    if [[ -z "$current_state" ]]; then
        echo "Server not found in state"
        return
    fi

    # Get all sources for this server from raw discovery
    local all_sources
    all_sources=$(discover_and_parse_all_sources | grep ":$server:")

    # Find where server is enabled/disabled (highest priority enable/disable directive)
    local state_scope=""
    local state_file=""
    local state_priority=0

    while IFS=: read -r type srv scope file; do
        if [[ "$type" == "enable" ]] || [[ "$type" == "disable" ]]; then
            local priority
            priority=$(get_scope_priority "$scope")
            if [[ $priority -gt $state_priority ]]; then
                state_priority=$priority
                state_scope="$scope"
                state_file="$file"
            fi
        fi
    done <<< "$all_sources"

    # Display header
    echo -e "${COLOR_CYAN}Server:${COLOR_RESET} ${COLOR_WHITE}$server${COLOR_RESET}"
    echo ""

    # Show definition source
    echo -e "${COLOR_CYAN}Defined In:${COLOR_RESET} $def_file ($def_scope)"

    # Show state source if different from definition source
    if [[ -n "$state_file" ]] && [[ "$state_file" != "$def_file" ]]; then
        local state_type
        if [[ "$current_state" == "on" ]]; then
            state_type="Enabled"
        else
            state_type="Disabled"
        fi
        echo -e "${COLOR_CYAN}$state_type In:${COLOR_RESET} $state_file ($state_scope)"
    fi

    echo ""

    # Show all sources if there are multiple definitions or enable/disable directives
    local def_count
    def_count=$(echo "$all_sources" | grep "^def:" | wc -l)
    local state_count
    state_count=$(echo "$all_sources" | grep -E "^(enable|disable):" | wc -l)

    if [[ $def_count -gt 1 ]] || [[ $state_count -gt 1 ]]; then
        echo -e "${COLOR_CYAN}All Sources:${COLOR_RESET}"
        while IFS=: read -r type srv scope file; do
            local display_type
            case "$type" in
                def) display_type="${COLOR_BLUE}DEFINED${COLOR_RESET}" ;;
                enable) display_type="${COLOR_GREEN}ENABLED${COLOR_RESET}" ;;
                disable) display_type="${COLOR_RED}DISABLED${COLOR_RESET}" ;;
            esac

            local marker=""
            # Mark active definition
            if [[ "$type" == "def" ]] && [[ "$scope" == "$def_scope" ]] && [[ "$file" == "$def_file" ]]; then
                marker=" ${COLOR_GREEN}✓ active${COLOR_RESET}"
            fi
            # Mark active state
            if [[ "$type" == "enable" || "$type" == "disable" ]] && [[ "$scope" == "$state_scope" ]] && [[ "$file" == "$state_file" ]]; then
                marker=" ${COLOR_GREEN}✓ active${COLOR_RESET}"
            fi

            echo -e "  • $file ($scope) - $display_type$marker"
        done <<< "$all_sources"
        echo ""
    fi

    # Current and pending status
    local current_status
    local pending_status
    if [[ "$current_state" == "on" ]]; then
        current_status="${COLOR_GREEN}Enabled${COLOR_RESET}"
        pending_status="${COLOR_GREEN}Enabled${COLOR_RESET}"
    else
        current_status="${COLOR_RED}Disabled${COLOR_RESET}"
        pending_status="${COLOR_RED}Disabled${COLOR_RESET}"
    fi

    echo -e "${COLOR_CYAN}Current Status:${COLOR_RESET} $current_status"
    echo -e "${COLOR_CYAN}After Confirm:${COLOR_RESET} $pending_status"
    echo ""
    echo -e "${COLOR_YELLOW}Changes saved to:${COLOR_RESET} ./.claude/settings.local.json"
    echo ""
    echo -e "${COLOR_YELLOW}Tip:${COLOR_RESET} Press ${COLOR_CYAN}SPACE${COLOR_RESET} to toggle"
}

# ============================================================================
# SERVER MANAGEMENT FLOWS
# ============================================================================

# Interactive flow to add a new server
add_server_flow() {
    # Redirect to tty to get input from user
    exec < /dev/tty

    echo ""
    echo -e "${COLOR_CYAN}Add New Server${COLOR_RESET}"
    echo ""
    read -rp "Enter server name (or press Enter to cancel): " server_name

    if [[ -z "$server_name" ]]; then
        echo "Cancelled"
        sleep 0.5
        return 0
    fi

    if add_server "$server_name"; then
        msg_success "Added $server_name"
        sleep 0.5
    else
        sleep 1
    fi
}

# Interactive flow to remove a server
# Args: $1 - server line from fzf
remove_server_flow() {
    local raw_input="$1"

    # Strip to get server name
    local server
    server=$(echo "$raw_input" | sed 's/\x1b\[[0-9;]*m//g' | sed 's/^\[ON \] *//' | sed 's/^\[OFF\] *//' | sed 's/^     *//')

    if [[ -z "$server" ]]; then
        return 0
    fi

    # Redirect to tty to get input from user
    exec < /dev/tty

    echo ""
    echo -e "${COLOR_YELLOW}Remove Server: ${COLOR_WHITE}$server${COLOR_RESET}"
    echo ""
    read -rp "Are you sure? (y/N): " confirm

    if [[ "$confirm" =~ ^[Yy]$ ]]; then
        remove_server "$server"
        msg_success "Removed $server"
        sleep 0.5
    else
        echo "Cancelled"
        sleep 0.5
    fi
}

# ============================================================================
# MAIN TUI LAUNCHER
# ============================================================================

# Launch fzf TUI with all bindings and interactions
launch_fzf_tui() {
    # Export functions and variables for fzf subshells
    export STATE_FILE
    export COLOR_RESET COLOR_RED COLOR_GREEN COLOR_YELLOW COLOR_BLUE COLOR_CYAN COLOR_WHITE
    export -f toggle_server generate_fzf_list add_server remove_server
    export -f enable_all_servers disable_all_servers
    export -f add_server_flow remove_server_flow msg_error msg_warning msg_success
    export -f discover_and_parse_all_sources get_scope_priority generate_preview
    export -f parse_settings_file parse_mcp_json_file parse_claude_json_file detect_file_format

    clear
    msg_header "MCP Server Selector v${VERSION}"
    echo -e "${COLOR_YELLOW}Write Target:${COLOR_RESET} ./.claude/settings.local.json"
    echo -e "${COLOR_YELLOW}Definitions:${COLOR_RESET} ~/.claude.json (user & local), ./.mcp.json (project)"
    echo -e "${COLOR_YELLOW}Enable/Disable:${COLOR_RESET} ~/.claude.json projects + all settings files"
    echo ""

    # Count servers by scope
    local total_count=0
    local enabled_count=0
    local local_count=0
    local project_count=0
    local user_count=0

    if [[ -f "$STATE_FILE" ]] && [[ -s "$STATE_FILE" ]]; then
        total_count=$(wc -l < "$STATE_FILE")
        enabled_count=$(grep -c '^on:' "$STATE_FILE" || echo "0")
        local_count=$(grep -c ':local:' "$STATE_FILE" || echo "0")
        project_count=$(grep -c ':project:' "$STATE_FILE" || echo "0")
        user_count=$(grep -c ':user:' "$STATE_FILE" || echo "0")
    fi

    echo -e "${COLOR_CYAN}${total_count} total${COLOR_RESET}  │  ${COLOR_GREEN}${enabled_count} enabled${COLOR_RESET}  │  ${COLOR_BLUE}${local_count} local, ${project_count} project, ${user_count} user${COLOR_RESET}"
    echo ""

    # Run fzf with dynamic bindings
    set +e  # Don't exit on fzf cancel

    generate_fzf_list | fzf \
        --ansi \
        --multi \
        --reverse \
        --height=80% \
        --border=rounded \
        --prompt="Filter: " \
        --pointer="▶" \
        --marker="→" \
        --header="[SPACE] Toggle | [ENTER] Save & Exit | [ESC] Cancel | [Ctrl-A] Add | [Ctrl-X] Remove
[Alt-E] Enable All | [Alt-D] Disable All" \
        --preview="generate_preview {}" \
        --preview-window="right:50%:wrap" \
        --bind="space:execute-silent(toggle_server {})+reload(generate_fzf_list)+refresh-preview" \
        --bind="alt-e:execute-silent(enable_all_servers)+reload(generate_fzf_list)+refresh-preview" \
        --bind="alt-d:execute-silent(disable_all_servers)+reload(generate_fzf_list)+refresh-preview" \
        --bind="ctrl-a:execute(add_server_flow)+reload(generate_fzf_list)+refresh-preview" \
        --bind="ctrl-x:execute(remove_server_flow {})+reload(generate_fzf_list)+refresh-preview" \
        --bind="enter:accept" \
        --bind="esc:abort" \
        --color="fg:#d0d0d0,bg:#121212,hl:#5fff87" \
        --color="fg+:#ffffff,bg+:#262626,hl+:#ffff00" \
        --color="info:#af87ff,prompt:#5fff87,pointer:#ff87d7" \
        --color="marker:#00ff00,spinner:#ff87d7,header:#87afaf" \
        > /dev/null

    local fzf_exit=$?
    set -e

    # Handle exit code
    if [[ $fzf_exit -eq 130 ]] || [[ $fzf_exit -eq 1 ]]; then
        # User cancelled (ESC or Ctrl-C)
        clear
        msg_warning "Cancelled - no changes saved"
        return 1
    elif [[ $fzf_exit -eq 0 ]]; then
        # User confirmed
        clear
        msg_success "Saving changes..."
        save_state_to_settings

        # Show summary
        local new_enabled_count
        new_enabled_count=$(grep -c '^on:' "$STATE_FILE" || echo "0")

        echo ""
        if [[ $new_enabled_count -eq 0 ]]; then
            msg_warning "No servers enabled"
        else
            echo -e "${COLOR_CYAN}Enabled servers (${new_enabled_count}):${COLOR_RESET}"
            while IFS=: read -r state server scope file; do
                if [[ "$state" == "on" ]]; then
                    local dim='\033[2m'
                    echo -e "  ${COLOR_GREEN}${MARK_SUCCESS}${COLOR_RESET} $server ${dim}($scope)${COLOR_RESET}"
                fi
            done < "$STATE_FILE"
        fi

        echo ""
        return 0
    else
        msg_error "Unexpected error (exit code: $fzf_exit)"
        return 1
    fi
}

# ============================================================================
# MAIN FUNCTION
# ============================================================================

main() {
    # Set up cleanup trap for state file
    STATE_FILE=$(mktemp)
    trap 'rm -f "$STATE_FILE"' EXIT

    # Check dependencies
    check_dependencies

    # Discover settings file (may trigger new project flow)
    discover_settings_file

    # Load servers into state file
    load_servers

    # Launch TUI
    if launch_fzf_tui; then
        # Success - launch Claude (unless in test mode)
        if [[ -n "${TEST_MODE:-}" ]]; then
            msg_success "Test mode - skipping Claude launch"
            exit 0
        fi

        msg_info "Launching Claude..."
        sleep 0.5

        # Find claude binary
        local claude_bin
        if [[ -L "$HOME/.local/bin/claude" ]]; then
            claude_bin=$(realpath_portable "$HOME/.local/bin/claude")
        elif command -v claude &> /dev/null; then
            claude_bin=$(command -v claude)
        else
            msg_error "Cannot find claude binary"
            exit 1
        fi

        exec "$claude_bin" "$@"
    else
        # User cancelled
        exit 0
    fi
}

# ============================================================================
# ENTRY POINT
# ============================================================================

main "$@"
