#!/usr/bin/env bash

# MCP Server Selector v2.0
# Production-grade TUI for managing Claude Code MCP servers
# Cross-platform (Linux/macOS) - Never modifies global config

set -euo pipefail

# ============================================================================
# CONSTANTS & GLOBALS
# ============================================================================

readonly SCRIPT_NAME="$(basename "$0")"
readonly VERSION="1.0.0"

# Color codes
readonly COLOR_RESET='\033[0m'
readonly COLOR_RED='\033[0;31m'
readonly COLOR_GREEN='\033[0;32m'
readonly COLOR_YELLOW='\033[1;33m'
readonly COLOR_BLUE='\033[0;34m'
readonly COLOR_CYAN='\033[0;36m'
readonly COLOR_WHITE='\033[1m'
readonly COLOR_ORANGE='\033[38;2;198;97;63m'  # Claude Code brand color: rgb(198, 97, 63)
readonly COLOR_GREY='\033[90m'  # Light grey for headers

# Markers
readonly MARK_ERROR="✗"
readonly MARK_SUCCESS="✓"
readonly MARK_WARNING="⚠"
readonly MARK_INFO="→"

# State file (created in main, cleaned up via trap)
STATE_FILE=""

# Settings file path (determined during discovery)
SETTINGS_FILE_PATH=""
SETTINGS_SCOPE=""

# ============================================================================
# UTILITY FUNCTIONS
# ============================================================================

# Portable realpath implementation (works on Linux + macOS)
# Args: $1 - path to resolve
# Returns: absolute path
realpath_portable() {
    local path="$1"

    if [[ -d "$path" ]]; then
        (cd "$path" && pwd)
    elif [[ -e "$path" ]]; then
        local dir=$(dirname "$path")
        local base=$(basename "$path")
        (cd "$dir" && echo "$(pwd)/$base")
    else
        echo "$path"
    fi
}

# Detect operating system
# Returns: "Linux" or "Darwin" or "Unknown"
detect_os() {
    local os
    os=$(uname -s)
    echo "$os"
}

# Messaging utilities
msg_info() {
    echo -e "${COLOR_CYAN}${MARK_INFO}${COLOR_RESET} $*"
}

msg_success() {
    echo -e "${COLOR_GREEN}${MARK_SUCCESS}${COLOR_RESET} $*"
}

msg_error() {
    echo -e "${COLOR_RED}${MARK_ERROR}${COLOR_RESET} $*" >&2
}

msg_warning() {
    echo -e "${COLOR_YELLOW}${MARK_WARNING}${COLOR_RESET} $*"
}

msg_header() {
    echo -e "${COLOR_WHITE}${COLOR_CYAN}$*${COLOR_RESET}"
}

# Get safe terminal width for lines
# Returns: width (defaults to 60 for narrow terminals)
get_term_width() {
    local cols
    cols=$(tput cols 2>/dev/null || echo 80)
    # Cap at reasonable max to prevent overflow, min at 60
    if [[ $cols -gt 100 ]]; then
        echo 80
    elif [[ $cols -lt 60 ]]; then
        echo 60
    else
        echo $((cols - 10))
    fi
}

# Generate horizontal line with character
# Args: $1 - character, $2 - width (optional, defaults to term width)
gen_line() {
    local char="${1:-─}"
    local width="${2:-$(get_term_width)}"
    printf '%*s' "$width" | tr ' ' "$char"
}

# Abbreviate path in fish-shell style
# Args: $1 - path to abbreviate
# Returns: abbreviated path (e.g., ~/.c/s.local.json)
abbreviate_path() {
    local path="$1"

    # Replace home directory with ~
    path="${path/#$HOME/\~}"

    # If path is in current directory, show as relative
    # Use exported MCP_CURRENT_DIR if available (for fzf preview context)
    local cwd="${MCP_CURRENT_DIR:-$(pwd)}"
    if [[ "$path" == "$cwd/"* ]]; then
        path="./${path#$cwd/}"
    elif [[ "$path" == "$cwd" ]]; then
        path="."
    fi

    # Abbreviate directory names (keep first letter only for non-terminal dirs)
    # Only abbreviate paths with 4+ components for readability
    local IFS='/'
    local -a parts=($path)
    local num_parts=${#parts[@]}
    local last_idx=$((num_parts - 1))

    # If path has fewer than 4 components, don't abbreviate (keeps it readable)
    if [[ $num_parts -lt 4 ]]; then
        echo "$path"
        return
    fi

    local result=""
    for i in "${!parts[@]}"; do
        local part="${parts[$i]}"

        # Skip empty components
        if [[ -z "$part" ]]; then
            continue
        fi

        # Keep special prefixes as-is (~, ., ..)
        if [[ "$part" == "~" ]] || [[ "$part" == "." ]] || [[ "$part" == ".." ]]; then
            result+="$part"
        elif [[ $i -eq $last_idx ]]; then
            # Last component - keep full name
            result+="/$part"
        else
            # Intermediate directory - abbreviate to first letter
            result+="/${part:0:1}"
        fi
    done

    # Clean up leading slash if path starts with ~ or .
    result="${result#/}"

    echo "$result"
}

# ============================================================================
# BOX DRAWING UTILITIES
# ============================================================================

# Strip ANSI escape codes from text for accurate length calculation
# Args: $1 - text with ANSI codes
# Returns: text without ANSI codes
strip_ansi() {
    local text="$1"
    # Comprehensive ANSI stripping: matches ESC [ ... [any letter]
    # This covers SGR (colors), cursor movement, erasing, etc.
    echo "$text" | sed -E 's/\x1b\[[0-9;]*[a-zA-Z]//g'
}

# Calculate visual width of text (excludes ANSI codes)
# Args: $1 - text (may contain ANSI codes)
# Returns: numeric width
visual_width() {
    local text="$1"
    local stripped
    stripped=$(strip_ansi "$text")
    echo "${#stripped}"
}

# Truncate text to fit within width with ellipsis
# Args: $1 - text, $2 - max width
# Returns: truncated text with ... if needed
truncate_text() {
    local text="$1"
    local max_width="$2"
    local vwidth
    vwidth=$(visual_width "$text")

    if [[ $vwidth -le $max_width ]]; then
        echo "$text"
    else
        # Strip ANSI, truncate, add ellipsis
        local stripped
        stripped=$(strip_ansi "$text")
        echo "${stripped:0:$((max_width - 3))}..."
    fi
}

# Extract clean server name from fzf selection
# Args: $1 - raw input from fzf (with ANSI codes, prefixes, badges, scope)
# Returns: clean server name
extract_server_name() {
    local raw_input="$1"
    echo "$raw_input" | \
        sed 's/\x1b\[[0-9;]*m//g' | \
        sed 's/^● *//' | \
        sed 's/^○ *//' | \
        sed 's/^⚠ *//' | \
        sed 's/^\[ON \] *//' | \
        sed 's/^\[OFF\] *//' | \
        sed 's/^\[⚠ \] *//' | \
        sed 's/^     *//' | \
        sed 's/ *\[plugin\] *//' | \
        sed 's/ *\[direct\] *//' | \
        sed 's/ *│.*//' | \
        awk '{print $1}'
}

# ============================================================================
# DEPENDENCY CHECKING
# ============================================================================

# Check for required dependencies (fzf, jq)
# Exits with error if missing, provides OS-specific installation instructions
check_dependencies() {
    local missing_deps=()

    for cmd in fzf jq; do
        if ! command -v "$cmd" &> /dev/null; then
            missing_deps+=("$cmd")
        fi
    done

    if [[ ${#missing_deps[@]} -eq 0 ]]; then
        return 0
    fi

    msg_error "Missing required dependencies: ${missing_deps[*]}"
    echo ""

    local os
    os=$(detect_os)

    case "$os" in
        Linux)
            # Detect Linux package manager
            if command -v apt &> /dev/null; then
                echo -e "${COLOR_CYAN}Install with:${COLOR_RESET}"
                echo "  sudo apt update && sudo apt install ${missing_deps[*]}"
            elif command -v dnf &> /dev/null; then
                echo -e "${COLOR_CYAN}Install with:${COLOR_RESET}"
                echo "  sudo dnf install ${missing_deps[*]}"
            elif command -v yum &> /dev/null; then
                echo -e "${COLOR_CYAN}Install with:${COLOR_RESET}"
                echo "  sudo yum install ${missing_deps[*]}"
            elif command -v pacman &> /dev/null; then
                echo -e "${COLOR_CYAN}Install with:${COLOR_RESET}"
                echo "  sudo pacman -S ${missing_deps[*]}"
            else
                echo -e "${COLOR_CYAN}Install using your system's package manager${COLOR_RESET}"
            fi
            ;;
        Darwin)
            if command -v brew &> /dev/null; then
                echo -e "${COLOR_CYAN}Install with:${COLOR_RESET}"
                echo "  brew install ${missing_deps[*]}"
            else
                echo -e "${COLOR_CYAN}Install Homebrew first:${COLOR_RESET}"
                echo "  /bin/bash -c \"\$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)\""
                echo ""
                echo -e "${COLOR_CYAN}Then install dependencies:${COLOR_RESET}"
                echo "  brew install ${missing_deps[*]}"
            fi
            ;;
        *)
            echo -e "${COLOR_CYAN}Please install: ${missing_deps[*]}${COLOR_RESET}"
            ;;
    esac

    exit 1
}

# ============================================================================
# FORMAT DETECTION & PARSING
# ============================================================================

# Detect configuration file format
# Args: $1 - file path
# Returns: "mcp" or "settings" or "unknown"
detect_file_format() {
    local file="$1"

    if [[ ! -f "$file" ]]; then
        echo "unknown"
        return 1
    fi

    if ! jq empty "$file" 2>/dev/null; then
        echo "unknown"
        return 1
    fi

    # Check for mcpServers object
    if jq -e '.mcpServers' "$file" >/dev/null 2>&1; then
        echo "mcp"
        return 0
    fi

    # Check for enabledMcpjsonServers or disabledMcpjsonServers arrays
    if jq -e '.enabledMcpjsonServers' "$file" >/dev/null 2>&1 || \
       jq -e '.disabledMcpjsonServers' "$file" >/dev/null 2>&1; then
        echo "settings"
        return 0
    fi

    echo "unknown"
    return 1
}

# Get numeric priority for scope (for precedence resolution)
# Args: $1 - scope label (local/project/user)
# Returns: numeric priority (3=highest, 1=lowest)
get_scope_priority() {
    case "$1" in
        local) echo 3 ;;
        project) echo 2 ;;
        user) echo 1 ;;
        *) echo 0 ;;
    esac
}

# Parse settings file (extracts enable/disable arrays ONLY, not mcpServers definitions)
# Args: $1 - file path, $2 - scope label (local/project/user)
# Output: Lines in format "type:server:scope:file"
# Types: enable (server enabled), disable (server disabled)
# Example: enable:fetch:user:~/.claude/settings.json
parse_settings_file() {
    local file="$1"
    local scope="$2"

    if [[ ! -f "$file" ]] || ! jq empty "$file" 2>/dev/null; then
        return 0
    fi

    # Extract enabled servers
    local enabled
    enabled=$(jq -r '.enabledMcpjsonServers[]? // empty' "$file" 2>/dev/null | sort -u)

    # Extract disabled servers
    local disabled
    disabled=$(jq -r '.disabledMcpjsonServers[]? // empty' "$file" 2>/dev/null | sort -u)

    # Output enabled servers
    if [[ -n "$enabled" ]]; then
        while IFS= read -r server; do
            [[ -n "$server" ]] && echo "enable:$server:$scope:$file"
        done <<< "$enabled"
    fi

    # Output disabled servers
    if [[ -n "$disabled" ]]; then
        while IFS= read -r server; do
            [[ -n "$server" ]] && echo "disable:$server:$scope:$file"
        done <<< "$disabled"
    fi
}

# Parse .mcp.json file (mcpServers object format only, no enable/disable arrays)
# Args: $1 - file path, $2 - scope label (project only, not used for ~/.claude.json)
# Output: Lines in format "def:server:scope:file:source_type"
# Example: def:coingecko:project:./.mcp.json:mcpjson
parse_mcp_json_file() {
    local file="$1"
    local scope="$2"

    if [[ ! -f "$file" ]] || ! jq empty "$file" 2>/dev/null; then
        return 0
    fi

    # Extract server names from mcpServers object keys
    local servers
    servers=$(jq -r '.mcpServers | keys[]? // empty' "$file" 2>/dev/null | sort -u)

    if [[ -n "$servers" ]]; then
        while IFS= read -r server; do
            [[ -n "$server" ]] && echo "def:$server:$scope:$file:mcpjson"
        done <<< "$servers"
    fi
}

# Parse ~/.claude.json file (handles BOTH user and project-specific scopes)
# Args: $1 - file path (~/.claude.json)
# Output: Lines in format "type:server:scope:file:source_type"
# Types: def (server defined), enable (server enabled), disable (server disabled)
# Scopes: user (root .mcpServers), local (under .projects[cwd])
# Source types: direct-global (root), direct-local (projects)
# Example: def:fetch:user:~/.claude.json:direct-global
#          def:stripe:local:~/.claude.json:direct-local
#          enable:time:local:~/.claude.json
parse_claude_json_file() {
    local file="$1"

    if [[ ! -f "$file" ]] || ! jq empty "$file" 2>/dev/null; then
        return 0
    fi

    # Get current working directory for project matching
    local cwd
    cwd=$(pwd)

    # Parse user-scope servers (root level .mcpServers) - DIRECT-GLOBAL (always enabled)
    local user_servers
    user_servers=$(jq -r '.mcpServers | keys[]? // empty' "$file" 2>/dev/null | sort -u)

    if [[ -n "$user_servers" ]]; then
        while IFS= read -r server; do
            [[ -n "$server" ]] && echo "def:$server:user:$file:direct-global"
        done <<< "$user_servers"
    fi

    # Parse local-scope servers (project-specific .projects[cwd].mcpServers) - DIRECT-LOCAL (always enabled)
    local local_servers
    local_servers=$(jq -r --arg cwd "$cwd" '.projects[$cwd].mcpServers | keys[]? // empty' "$file" 2>/dev/null | sort -u)

    if [[ -n "$local_servers" ]]; then
        while IFS= read -r server; do
            [[ -n "$server" ]] && echo "def:$server:local:$file:direct-local"
        done <<< "$local_servers"
    fi

    # Parse local-scope enabled servers (.projects[cwd].enabledMcpjsonServers)
    # NOTE: These are removed by Claude Code on launch, but we parse them for completeness
    local enabled
    enabled=$(jq -r --arg cwd "$cwd" '.projects[$cwd].enabledMcpjsonServers[]? // empty' "$file" 2>/dev/null | sort -u)

    if [[ -n "$enabled" ]]; then
        while IFS= read -r server; do
            [[ -n "$server" ]] && echo "enable:$server:local:$file"
        done <<< "$enabled"
    fi

    # Parse local-scope disabled servers (.projects[cwd].disabledMcpjsonServers)
    # NOTE: These are removed by Claude Code on launch, but we parse them for completeness
    local disabled
    disabled=$(jq -r --arg cwd "$cwd" '.projects[$cwd].disabledMcpjsonServers[]? // empty' "$file" 2>/dev/null | sort -u)

    if [[ -n "$disabled" ]]; then
        while IFS= read -r server; do
            [[ -n "$server" ]] && echo "disable:$server:local:$file"
        done <<< "$disabled"
    fi

    # Parse local-scope disabled DIRECT servers (.projects[cwd].disabledMcpServers)
    # This controls Direct-Global and Direct-Local servers (from .mcpServers sections)
    local disabled_direct
    disabled_direct=$(jq -r --arg cwd "$cwd" '.projects[$cwd].disabledMcpServers[]? // empty' "$file" 2>/dev/null | sort -u)

    if [[ -n "$disabled_direct" ]]; then
        while IFS= read -r server; do
            [[ -n "$server" ]] && echo "disable:$server:local:$file"
        done <<< "$disabled_direct"
    fi
}

# Parse enabledPlugins from settings files
# Args: $1 - file path, $2 - scope label (local/project/user)
# Output: Lines in format "type:plugin_server:scope:file"
# Types: enable (plugin enabled), disable (plugin disabled)
# Example: enable:mcp-fetch@claudecode-marketplace:user:~/.claude/settings.json
parse_enabled_plugins() {
    local file="$1"
    local scope="$2"

    if [[ ! -f "$file" ]] || ! jq empty "$file" 2>/dev/null; then
        return 0
    fi

    # Extract enabledPlugins object
    local plugins_json
    plugins_json=$(jq -r '.enabledPlugins // {}' "$file" 2>/dev/null)

    if [[ "$plugins_json" == "{}" ]]; then
        return 0
    fi

    # Parse each plugin: server -> enabled state
    echo "$plugins_json" | jq -r 'to_entries[] | "\(.key):\(.value)"' | while IFS=: read -r plugin_name enabled_state; do
        [[ -z "$plugin_name" ]] && continue

        if [[ "$enabled_state" == "true" ]]; then
            echo "enable:$plugin_name:$scope:$file"
        else
            echo "disable:$plugin_name:$scope:$file"
        fi
    done
}

# Discover plugin servers from marketplace installations
# Output: Lines in format "def:server:scope:file:plugin"
# Example: def:mcp-fetch@claudecode-marketplace:user:~/.claude/plugins/marketplaces/claudecode-marketplace/.claude-plugin/marketplace.json:plugin
parse_plugin_marketplace_files() {
    local marketplace_dir="$HOME/.claude/plugins/marketplaces"

    if [[ ! -d "$marketplace_dir" ]]; then
        return 0
    fi

    # Find all marketplace.json files
    while IFS= read -r marketplace_file; do
        [[ ! -f "$marketplace_file" ]] && continue
        [[ ! -s "$marketplace_file" ]] && continue

        # Validate JSON
        if ! jq empty "$marketplace_file" 2>/dev/null; then
            continue
        fi

        # Extract marketplace name from path
        # Path: ~/.claude/plugins/marketplaces/claudecode-marketplace/.claude-plugin/marketplace.json
        local marketplace_name
        marketplace_name=$(echo "$marketplace_file" | sed 's|.*/marketplaces/\([^/]*\)/.*|\1|')

        # Extract plugin names from plugins array where category == "mcpServers"
        # Use the plugin .name field (e.g., "mcp-fetch") not the mcpServers keys
        # This matches the format used in enabledPlugins
        local plugins
        plugins=$(jq -r '.plugins[]? | select(.category == "mcpServers") | .name // empty' "$marketplace_file" 2>/dev/null | sort -u)

        if [[ -n "$plugins" ]]; then
            while IFS= read -r plugin_name; do
                [[ -z "$plugin_name" ]] && continue
                # Append marketplace name to plugin for unique identification
                local plugin_server="${plugin_name}@${marketplace_name}"
                echo "def:$plugin_server:user:$marketplace_file:plugin"
            done <<< "$plugins"
        fi
    done < <(find "$marketplace_dir" -name "marketplace.json" 2>/dev/null)
}

# ============================================================================
# CONFIGURATION DISCOVERY & NEW PROJECT FLOW
# ============================================================================

# Check for configuration and handle new project flow if needed
# No longer sets SETTINGS_FILE_PATH or SETTINGS_SCOPE (multi-source approach)
discover_settings_file() {
    local current_dir
    current_dir=$(pwd)

    # Check if any local config exists
    if [[ -f "$current_dir/.claude/settings.local.json" ]] || \
       [[ -f "$current_dir/.claude/settings.json" ]] || \
       [[ -f "$current_dir/.mcp.json" ]]; then
        # Local config exists, proceed normally
        return 0
    fi

    # No local config, check if global exists
    if [[ -f "$HOME/.claude/settings.json" ]] || \
       [[ -f "$HOME/.claude/settings.local.json" ]] || \
       [[ -f "$HOME/.claude.json" ]]; then
        # Global config exists, trigger new project flow
        handle_new_project_prompt
        return $?
    fi

    # No configuration found anywhere
    msg_error "No Claude configuration found (local or global)"
    echo ""
    echo "Please configure Claude first by running 'claude' once."
    exit 1
}

# Handle new project initialization flow
# Prompts user to create local config or use global
handle_new_project_prompt() {
    clear
    msg_header "New Project Detected"
    echo ""
    echo "You are in a directory without a local Claude configuration."
    echo "Global configuration will be used as a template."
    echo ""
    echo "What would you like to do?"
    echo ""
    echo "  ${COLOR_GREEN}1)${COLOR_RESET} Create local configuration (.claude/settings.local.json) for this project ${COLOR_CYAN}(Recommended)${COLOR_RESET}"
    echo "  ${COLOR_YELLOW}2)${COLOR_RESET} Continue with global settings only (changes will still be saved to local)"
    echo "  ${COLOR_RED}3)${COLOR_RESET} Abort"
    echo ""

    local choice
    read -rp "Enter your choice [1-3]: " choice

    case "$choice" in
        1)
            # Create local config from global template
            msg_info "Creating local configuration..."
            mkdir -p ./.claude

            # Find global settings file to use as template
            local template=""
            if [[ -f "$HOME/.claude/settings.json" ]]; then
                template="$HOME/.claude/settings.json"
            elif [[ -f "$HOME/.claude/settings.local.json" ]]; then
                template="$HOME/.claude/settings.local.json"
            elif [[ -f "$HOME/.claude.json" ]]; then
                template="$HOME/.claude.json"
            else
                # Create empty settings
                echo '{}' > "./.claude/settings.local.json"
                msg_success "Created empty ./.claude/settings.local.json"
                echo ""
                return 0
            fi

            cp "$template" "./.claude/settings.local.json"
            msg_success "Created ./.claude/settings.local.json from $template"
            echo ""
            return 0
            ;;
        2)
            # Continue without creating local config
            # Changes will still be saved to .claude/settings.local.json when user confirms
            msg_info "Continuing with global settings..."
            echo ""
            return 0
            ;;
        3|*)
            # Abort
            msg_warning "Operation cancelled"
            exit 0
            ;;
    esac
}

# ============================================================================
# STATE MANAGEMENT
# ============================================================================

# Discover and parse all configuration sources
# mcpServers definitions can exist in:
#   - ~/.claude.json (user-scope root & project-scope .projects[cwd]) - DIRECT (always enabled)
#   - ~/.mcp.json (user-scope) - MCPJSON (controllable)
#   - ./.mcp.json (project-scope) - MCPJSON (controllable)
# Enable/disable arrays ONLY work for MCPJSON servers (from .mcp.json files)
# Output: Lines in format "type:server:scope:file:source_type"
discover_and_parse_all_sources() {
    local temp_raw
    temp_raw=$(mktemp)

    # Parse ~/.claude.json (handles both user-scope root AND local-scope project entries)
    # Also extracts enable/disable arrays from .projects[cwd] (though Claude Code removes them)
    parse_claude_json_file "$HOME/.claude.json" >> "$temp_raw"

    # Parse ~/.mcp.json (user-scope mcpServers - MCPJSON type, controllable)
    parse_mcp_json_file "$HOME/.mcp.json" "user" >> "$temp_raw"

    # Parse ./.mcp.json (project-scope mcpServers - MCPJSON type, controllable)
    parse_mcp_json_file "./.mcp.json" "project" >> "$temp_raw"

    # Parse enable/disable arrays from all settings files (reverse precedence order)
    # User scope (lowest priority)
    parse_settings_file "$HOME/.claude/settings.json" "user" >> "$temp_raw"
    parse_settings_file "$HOME/.claude/settings.local.json" "user" >> "$temp_raw"

    # Project scope
    parse_settings_file "./.claude/settings.json" "project" >> "$temp_raw"

    # Local scope (highest priority)
    parse_settings_file "./.claude/settings.local.json" "local" >> "$temp_raw"

    # Parse plugin servers from marketplace installations
    parse_plugin_marketplace_files >> "$temp_raw"

    # Parse enabledPlugins from all settings files (reverse precedence order)
    # User scope (lowest priority)
    parse_enabled_plugins "$HOME/.claude/settings.json" "user" >> "$temp_raw"
    parse_enabled_plugins "$HOME/.claude/settings.local.json" "user" >> "$temp_raw"

    # Project scope
    parse_enabled_plugins "./.claude/settings.json" "project" >> "$temp_raw"

    # Local scope (highest priority)
    parse_enabled_plugins "./.claude/settings.local.json" "local" >> "$temp_raw"

    cat "$temp_raw"
    rm -f "$temp_raw"
}

# Load servers from all sources with DUAL precedence resolution
# Separates server definitions from enable/disable state
# State format: "state:server:def_scope:def_file:source_type" (one per line)
# Example: "on:fetch:project:./.mcp.json:mcpjson"
# Where state=on/off, def_scope/def_file=where server is DEFINED, source_type=mcpjson/direct-global/direct-local
load_servers() {
    local raw_data
    raw_data=$(discover_and_parse_all_sources)

    if [[ -z "$raw_data" ]]; then
        msg_warning "No MCP servers found in any configuration file"
        echo ""
        msg_info "You can add servers using Ctrl-A in the TUI"
        echo ""
        touch "$STATE_FILE"
        return 0
    fi

    # Build two separate maps for dual precedence resolution
    # Map 1: Server definitions (where server is configured)
    # Key: server_name, Value: priority:scope:file:source_type
    declare -A server_definitions

    # Map 2: Enable/disable state (whether server is active)
    # Key: server_name, Value: priority:state (on/off)
    declare -A server_states

    # Parse raw data and populate both maps
    while IFS=: read -r type server scope file source_type; do
        [[ -z "$server" ]] && continue

        local priority
        priority=$(get_scope_priority "$scope")

        if [[ "$type" == "def" ]]; then
            # This is a server definition
            local new_value="$priority:$scope:$file:$source_type"

            if [[ -n "${server_definitions[$server]:-}" ]]; then
                local existing_priority
                existing_priority=$(echo "${server_definitions[$server]}" | cut -d: -f1)

                # Higher priority wins (3 > 2 > 1)
                if [[ $priority -gt $existing_priority ]]; then
                    server_definitions[$server]="$new_value"
                fi
            else
                server_definitions[$server]="$new_value"
            fi

        elif [[ "$type" == "enable" ]]; then
            # This is an enable directive
            local new_value="$priority:on"

            if [[ -n "${server_states[$server]:-}" ]]; then
                local existing_priority
                existing_priority=$(echo "${server_states[$server]}" | cut -d: -f1)

                if [[ $priority -gt $existing_priority ]]; then
                    server_states[$server]="$new_value"
                fi
            else
                server_states[$server]="$new_value"
            fi

        elif [[ "$type" == "disable" ]]; then
            # This is a disable directive
            local new_value="$priority:off"

            if [[ -n "${server_states[$server]:-}" ]]; then
                local existing_priority
                existing_priority=$(echo "${server_states[$server]}" | cut -d: -f1)

                if [[ $priority -gt $existing_priority ]]; then
                    server_states[$server]="$new_value"
                fi
            else
                server_states[$server]="$new_value"
            fi
        fi
    done <<< "$raw_data"

    # Write to state file
    > "$STATE_FILE"  # Truncate

    # Merge: For each defined server, attach its state and source type
    for server in "${!server_definitions[@]}"; do
        local def_value="${server_definitions[$server]}"
        # Extract scope:file:source_type from priority:scope:file:source_type
        local def_scope def_file source_type
        def_scope=$(echo "$def_value" | cut -d: -f2)
        def_file=$(echo "$def_value" | cut -d: -f3)
        source_type=$(echo "$def_value" | cut -d: -f4)

        # Get state (default to "on" if not mentioned in any enable/disable array)
        # MCPJSON servers are enabled by default unless explicitly disabled
        # DIRECT servers are ALWAYS enabled (but we track state for migration purposes)
        local state="on"
        if [[ -n "${server_states[$server]:-}" ]]; then
            local state_value="${server_states[$server]}"
            state=$(echo "$state_value" | cut -d: -f2)
        fi

        echo "$state:$server:$def_scope:$def_file:$source_type" >> "$STATE_FILE"
    done

    # Sort state file by server name
    sort -t: -k2 "$STATE_FILE" -o "$STATE_FILE"
}

# ============================================================================
# MIGRATION HELPER FUNCTIONS
# ============================================================================

# Check if server has already been migrated to ./.mcp.json
# Args: $1 - server name
# Returns: 0 if migrated, 1 if not
# Validates actual migration state (not just tracking file)
is_server_migrated() {
    local server="$1"
    local migrations_file="./.claude/.mcp_migrations"
    local cwd=$(pwd)

    # Check if marked as migrated
    if [[ ! -f "$migrations_file" ]] || ! grep -q "^$server:" "$migrations_file" 2>/dev/null; then
        return 1
    fi

    # Validate migration is still valid:
    # 1. Server exists in ./.mcp.json
    # 2. Server does NOT exist in ~/.claude.json (root or projects)

    # Check if server exists in ./.mcp.json
    if [[ -f "./.mcp.json" ]]; then
        if ! jq -e --arg srv "$server" '.mcpServers[$srv]' "./.mcp.json" >/dev/null 2>&1; then
            # Server not in ./.mcp.json, migration invalid
            return 1
        fi
    else
        # No ./.mcp.json file, migration invalid
        return 1
    fi

    # Check if server still exists in ~/.claude.json (shouldn't if migrated)
    if [[ -f "$HOME/.claude.json" ]]; then
        # Check root .mcpServers
        if jq -e --arg srv "$server" '.mcpServers[$srv]' "$HOME/.claude.json" >/dev/null 2>&1; then
            # Server still in ~/.claude.json root, migration invalid
            return 1
        fi

        # Check .projects[cwd].mcpServers
        if jq -e --arg cwd "$cwd" --arg srv "$server" '.projects[$cwd].mcpServers[$srv]' "$HOME/.claude.json" >/dev/null 2>&1; then
            # Server still in ~/.claude.json projects, migration invalid
            return 1
        fi
    fi

    # All checks passed - migration is valid
    return 0
}

# Mark server as migrated
# Args: $1 - server name
mark_server_migrated() {
    local server="$1"
    local migrations_file="./.claude/.mcp_migrations"

    mkdir -p "./.claude"
    echo "$server:$(date +%s)" >> "$migrations_file"
}

# Get server source type from state file
# Args: $1 - server name
# Returns: source type (mcpjson, direct-global, direct-local) or empty
get_server_source_type() {
    local server="$1"

    while IFS=: read -r state srv scope file source_type; do
        if [[ "$srv" == "$server" ]]; then
            echo "$source_type"
            return 0
        fi
    done < "$STATE_FILE"

    return 1
}

# Get server definition file and scope from state file
# Args: $1 - server name
# Returns: "scope:file" or empty
get_server_definition_location() {
    local server="$1"

    while IFS=: read -r state srv scope file source_type; do
        if [[ "$srv" == "$server" ]]; then
            echo "$scope:$file"
            return 0
        fi
    done < "$STATE_FILE"

    return 1
}

# Extract server definition from source file
# Args: $1 - server name, $2 - source file, $3 - source type
# Returns: JSON definition of server
extract_server_definition() {
    local server="$1"
    local source_file="$2"
    local source_type="$3"
    local cwd=$(pwd)

    if [[ "$source_type" == "direct-global" ]]; then
        # From ~/.claude.json root .mcpServers
        jq -r --arg srv "$server" '.mcpServers[$srv]' "$source_file"
    elif [[ "$source_type" == "direct-local" ]]; then
        # From ~/.claude.json .projects[cwd].mcpServers
        jq -r --arg cwd "$cwd" --arg srv "$server" '.projects[$cwd].mcpServers[$srv]' "$source_file"
    else
        # From .mcp.json file
        jq -r --arg srv "$server" '.mcpServers[$srv]' "$source_file"
    fi
}

# Migrate server from ~/.claude.json to ./.mcp.json
# Args: $1 - server name
# Returns: 0 on success, 1 on failure
migrate_server_to_project_mcpjson() {
    local server="$1"

    # Get server location and source type
    local location source_type def_scope def_file
    location=$(get_server_definition_location "$server")
    if [[ -z "$location" ]]; then
        msg_error "Cannot find server '$server' in state"
        return 1
    fi

    def_scope=$(echo "$location" | cut -d: -f1)
    def_file=$(echo "$location" | cut -d: -f2-)
    source_type=$(get_server_source_type "$server")

    # Only migrate if it's a direct server
    if [[ "$source_type" != "direct-global" ]] && [[ "$source_type" != "direct-local" ]]; then
        msg_error "Server '$server' is not a direct server (type: $source_type)"
        return 1
    fi

    msg_info "Migrating '$server' to ./.mcp.json for project-level control..."
    echo ""

    # Create backup of ~/.claude.json
    local backup_file="$HOME/.claude.json.backup.$(date +%Y%m%d_%H%M%S)"
    if ! cp "$def_file" "$backup_file" 2>/dev/null; then
        msg_error "Failed to create backup of $def_file"
        return 1
    fi
    msg_info "Backup created: $backup_file"

    # Extract server definition
    local definition
    definition=$(extract_server_definition "$server" "$def_file" "$source_type")
    if [[ -z "$definition" ]] || [[ "$definition" == "null" ]]; then
        msg_error "Failed to extract server definition"
        rm "$backup_file"
        return 1
    fi

    # Create ./.mcp.json if it doesn't exist
    if [[ ! -f "./.mcp.json" ]]; then
        echo '{"mcpServers":{}}' > "./.mcp.json"
        msg_info "Created ./.mcp.json"
    fi

    # Add to ./.mcp.json (atomic operation)
    local temp_dest=$(mktemp)
    if ! jq --arg srv "$server" --argjson def "$definition" \
        '.mcpServers[$srv] = $def' "./.mcp.json" > "$temp_dest" 2>/dev/null; then
        msg_error "Failed to add server to ./.mcp.json"
        rm "$temp_dest" "$backup_file"
        return 1
    fi
    mv "$temp_dest" "./.mcp.json"
    msg_success "Added to ./.mcp.json"

    # Remove from ~/.claude.json (atomic operation)
    local temp_src=$(mktemp)
    local cwd=$(pwd)

    if [[ "$source_type" == "direct-global" ]]; then
        # Remove from root .mcpServers
        if ! jq --arg srv "$server" 'del(.mcpServers[$srv])' "$def_file" > "$temp_src" 2>/dev/null; then
            msg_error "Failed to remove server from $def_file"
            rm "$temp_src" "$backup_file"
            return 1
        fi
    elif [[ "$source_type" == "direct-local" ]]; then
        # Remove from .projects[cwd].mcpServers
        if ! jq --arg cwd "$cwd" --arg srv "$server" \
            'del(.projects[$cwd].mcpServers[$srv])' "$def_file" > "$temp_src" 2>/dev/null; then
            msg_error "Failed to remove server from $def_file"
            rm "$temp_src" "$backup_file"
            return 1
        fi
    fi

    # Validate both JSON files
    if ! jq empty "$temp_src" 2>/dev/null || ! jq empty "./.mcp.json" 2>/dev/null; then
        msg_error "JSON validation failed, rolling back"
        mv "$backup_file" "$def_file"
        rm "$temp_src"
        return 1
    fi

    mv "$temp_src" "$def_file"
    msg_success "Removed from $def_file"

    # Mark as migrated
    mark_server_migrated "$server"

    echo ""
    msg_success "Migration complete!"
    msg_info "Server '$server' can now be controlled via project settings"
    echo ""

    return 0
}

# Prompt user for migration with interactive options
# Args: $1 - server name, $2 - source type, $3 - source file
# Returns: 0 if user wants to migrate, 1 if not
prompt_for_migration() {
    local server="$1"
    local source_type="$2"
    local source_file="$3"

    # Redirect stdin and stdout to tty to show prompts in fzf context
    exec < /dev/tty > /dev/tty

    echo ""
    echo ""
    echo ""
    echo -e "${COLOR_YELLOW}═══════════════════════════════════════════════════${COLOR_RESET}"
    echo -e "${COLOR_WHITE}  Migration Required: ${COLOR_CYAN}$server${COLOR_RESET}"
    echo -e "${COLOR_YELLOW}═══════════════════════════════════════════════════${COLOR_RESET}"
    echo ""
    echo "This server is defined in:"
    echo -e "  ${COLOR_CYAN}$source_file${COLOR_RESET}"
    echo ""
    echo -e "Servers in this location are ${COLOR_RED}ALWAYS ENABLED${COLOR_RESET}."
    echo ""
    echo "To disable it, this tool must:"
    echo -e "  ${COLOR_GREEN}1.${COLOR_RESET} MOVE definition → ${COLOR_CYAN}./.mcp.json${COLOR_RESET} (project)"
    echo -e "  ${COLOR_GREEN}2.${COLOR_RESET} REMOVE from → ${COLOR_CYAN}$source_file${COLOR_RESET}"
    echo -e "  ${COLOR_GREEN}3.${COLOR_RESET} Disable via → ${COLOR_CYAN}./.claude/settings.local.json${COLOR_RESET}"
    echo ""
    echo -e "${COLOR_YELLOW}⚠ This MODIFIES your global config!${COLOR_RESET}"
    echo -e "  (A timestamped backup will be created first)"
    echo ""
    echo -e "${COLOR_WHITE}What would you like to do?${COLOR_RESET}"
    echo ""
    echo -e "  ${COLOR_GREEN}[y] Yes - Migrate and disable${COLOR_RESET}"
    echo "      • Performs all 3 steps above automatically"
    echo "      • Server becomes controllable in this project"
    echo "      • Server will be DISABLED after migration"
    echo "      • Global config is modified (backup created)"
    echo -e "      • ${COLOR_CYAN}Recommended if you want project-level control${COLOR_RESET}"
    echo ""
    echo -e "  ${COLOR_BLUE}[v] View - Show server definition${COLOR_RESET}"
    echo "      • Displays the full JSON configuration"
    echo "      • Helps you understand what will be migrated"
    echo "      • You can decide after viewing"
    echo "      • No changes made until you confirm"
    echo ""
    echo -e "  ${COLOR_RED}[n] No - Keep enabled globally${COLOR_RESET}"
    echo "      • Cancels migration process"
    echo "      • Server remains in $source_file"
    echo "      • Server stays ALWAYS ENABLED"
    echo "      • No changes made to any files"
    echo ""

    while true; do
        read -rp "Your choice [y/v/n]: " choice
        case "$choice" in
            y|Y)
                return 0
                ;;
            v|V)
                # Show definition
                echo ""
                echo -e "${COLOR_CYAN}Server Definition:${COLOR_RESET}"
                echo ""
                extract_server_definition "$server" "$source_file" "$source_type" | jq .
                echo ""
                read -rp "Migrate this to ./.mcp.json? [y/n]: " confirm
                if [[ "$confirm" =~ ^[Yy]$ ]]; then
                    return 0
                else
                    return 1
                fi
                ;;
            n|N)
                msg_warning "Migration cancelled - server will remain enabled"
                sleep 1
                return 1
                ;;
            *)
                echo -e "${COLOR_RED}Invalid choice. Please enter y, v, or n${COLOR_RESET}"
                ;;
        esac
    done
}

# Toggle server state in state file
# Args: $1 - server name (may have prefix like "[ON ] server-name (scope)")
# NEW: Direct servers now toggle normally (quick-disable)
toggle_server() {
    local raw_input="$1"
    local server
    server=$(extract_server_name "$raw_input")

    # Get source type
    local source_type
    source_type=$(get_server_source_type "$server")

    # NEW: Direct servers now toggle normally (quick-disable)
    if [[ "$source_type" == "direct-global" ]] || [[ "$source_type" == "direct-local" ]]; then
        # Simple toggle in state file (same as MCPJSON)
        local temp_state
        temp_state=$(mktemp)

        while IFS=: read -r state srv scope file stype; do
            if [[ "$srv" == "$server" ]]; then
                # Toggle state, preserve scope, file, and source type
                if [[ "$state" == "on" ]]; then
                    echo "off:$srv:$scope:$file:$stype" >> "$temp_state"
                else
                    echo "on:$srv:$scope:$file:$stype" >> "$temp_state"
                fi
            else
                # Keep unchanged
                echo "$state:$srv:$scope:$file:$stype" >> "$temp_state"
            fi
        done < "$STATE_FILE"

        mv "$temp_state" "$STATE_FILE"
        return 0
    fi

    # EXISTING: MCPJSON servers (no changes)
    local temp_state
    temp_state=$(mktemp)

    while IFS=: read -r state srv scope file source_type; do
        if [[ "$srv" == "$server" ]]; then
            # Toggle state, preserve scope, file, and source type
            if [[ "$state" == "on" ]]; then
                echo "off:$srv:$scope:$file:$source_type" >> "$temp_state"
            else
                echo "on:$srv:$scope:$file:$source_type" >> "$temp_state"
            fi
        else
            # Keep unchanged
            echo "$state:$srv:$scope:$file:$source_type" >> "$temp_state"
        fi
    done < "$STATE_FILE"

    mv "$temp_state" "$STATE_FILE"
}

# Add new server to state file (disabled by default, local scope, mcpjson type)
# Args: $1 - server name
# Note: Added servers are placeholders - user must define them in .mcp.json manually
add_server() {
    local server="$1"

    # Validate server name (alphanumeric, dashes, underscores)
    if [[ ! "$server" =~ ^[a-zA-Z0-9_-]+$ ]]; then
        msg_error "Invalid server name. Use only alphanumeric characters, dashes, and underscores."
        return 1
    fi

    # Check for duplicates (check column 2 for server name)
    if grep -q "^[^:]*:$server:" "$STATE_FILE" 2>/dev/null; then
        msg_warning "Server '$server' already exists"
        return 1
    fi

    # Add to state file (disabled, project scope, .mcp.json, mcpjson type)
    # Note: This assumes user will define the server in ./.mcp.json
    echo "off:$server:project:./.mcp.json:mcpjson" >> "$STATE_FILE"
    sort -t: -k2 "$STATE_FILE" -o "$STATE_FILE"
}

# Remove server from state file
# Args: $1 - server name (may have prefix and scope suffix)
remove_server() {
    local raw_input="$1"
    local server
    server=$(extract_server_name "$raw_input")

    # Remove from state file (match server name in column 2)
    local temp_state
    temp_state=$(mktemp)

    while IFS=: read -r state srv scope file source_type; do
        if [[ "$srv" != "$server" ]]; then
            echo "$state:$srv:$scope:$file:$source_type" >> "$temp_state"
        fi
    done < "$STATE_FILE"

    mv "$temp_state" "$STATE_FILE"
}

# Enable all servers in state file (preserve scope, file, and source type metadata)
enable_all_servers() {
    local temp_state
    temp_state=$(mktemp)

    while IFS=: read -r state srv scope file source_type; do
        echo "on:$srv:$scope:$file:$source_type" >> "$temp_state"
    done < "$STATE_FILE"

    mv "$temp_state" "$STATE_FILE"
}

# Disable all servers in state file (preserve scope, file, and source type metadata)
disable_all_servers() {
    local temp_state
    temp_state=$(mktemp)

    while IFS=: read -r state srv scope file source_type; do
        echo "off:$srv:$scope:$file:$source_type" >> "$temp_state"
    done < "$STATE_FILE"

    mv "$temp_state" "$STATE_FILE"
}

# Get plugin value from project-level settings file
# Args: $1 - plugin server name (e.g., "mcp-fetch@claudecode-marketplace")
# Returns: "true", "false", or "unset"
get_project_plugin_value() {
    local plugin="$1"
    local project_settings="./.claude/settings.json"

    if [[ ! -f "$project_settings" ]]; then
        echo "unset"
        return
    fi

    local value
    value=$(jq -r --arg plugin "$plugin" 'if .enabledPlugins | has($plugin) then .enabledPlugins[$plugin] else "unset" end' "$project_settings" 2>/dev/null)
    echo "$value"
}

# Check if a plugin is enabled in any lower-priority scope
# Args: $1 - plugin server name (e.g., "mcp-fetch@claudecode-marketplace")
# Returns: 0 if plugin is enabled in lower-priority scope, 1 if not
# This is used to decide: write explicit false (override) vs omit (avoid UI disappearance)
plugin_enabled_in_lower_scope() {
    local plugin="$1"
    local target_scope="local"  # We write to local scope
    local target_priority
    target_priority=$(get_scope_priority "$target_scope")

    # Parse all sources to find plugin enable directives in lower-priority scopes
    local all_sources
    all_sources=$(discover_and_parse_all_sources)

    while IFS=: read -r type srv scope file; do
        [[ "$srv" != "$plugin" ]] && continue
        [[ "$type" != "enable" ]] && continue

        local priority
        priority=$(get_scope_priority "$scope")

        # If this enable directive has lower priority than our target, return true
        if [[ $priority -lt $target_priority ]]; then
            return 0
        fi
    done <<< "$all_sources"

    return 1
}

# Save state file to project-local settings only (./.claude/settings.local.json)
# Never modifies global user settings
save_state_to_settings() {
    local target="./.claude/settings.local.json"

    # Create .claude directory if it doesn't exist
    if [[ ! -d "./.claude" ]]; then
        mkdir -p "./.claude"
        msg_info "Created .claude/ directory"
    fi

    # Parse state file into categories
    local enabled_mcpjson=()
    local disabled_mcpjson=()
    local disabled_direct=()  # Track Direct servers separately
    declare -A enabled_plugins  # Track plugin servers (name -> state)

    while IFS=: read -r state server scope file source_type; do
        [[ -z "$server" ]] && continue

        # Handle Direct servers separately
        if [[ "$source_type" == "direct-global" ]] || [[ "$source_type" == "direct-local" ]]; then
            if [[ "$state" == "off" ]]; then
                disabled_direct+=("$server")
            fi
            continue
        fi

        # Handle Plugin servers with smart precedence-aware strategy
        if [[ "$source_type" == "plugin" ]]; then
            if [[ "$state" == "on" ]]; then
                # Plugin is enabled - write explicit true
                enabled_plugins["$server"]="true"
            else
                # Plugin is disabled - check if we need explicit false or omit
                if plugin_enabled_in_lower_scope "$server"; then
                    # Plugin is enabled at lower-priority scope (e.g., project/user)
                    # Write explicit false to override it
                    enabled_plugins["$server"]="false"
                fi
                # Otherwise omit (plugin not enabled elsewhere, avoid UI disappearance)
            fi
            continue
        fi

        # MCPJSON servers
        if [[ "$state" == "on" ]]; then
            enabled_mcpjson+=("$server")
        elif [[ "$state" == "off" ]]; then
            disabled_mcpjson+=("$server")
        fi
    done < "$STATE_FILE"

    # Build JSON arrays for MCPJSON servers
    local enabled_json
    local disabled_json

    if [[ ${#enabled_mcpjson[@]} -eq 0 ]]; then
        enabled_json="[]"
    else
        enabled_json=$(printf '%s\n' "${enabled_mcpjson[@]}" | jq -R . | jq -s -c .)
    fi

    if [[ ${#disabled_mcpjson[@]} -eq 0 ]]; then
        disabled_json="[]"
    else
        disabled_json=$(printf '%s\n' "${disabled_mcpjson[@]}" | jq -R . | jq -s -c .)
    fi

    # Initialize with empty object if file doesn't exist
    if [[ ! -f "$target" ]]; then
        echo '{}' > "$target"
        msg_info "Created $target"
    fi

    # Build enabledPlugins JSON object (with redundancy elimination)
    local plugins_json="{}"
    # Safe check for non-empty associative array with set -u
    local plugin_count=0
    for _ in "${!enabled_plugins[@]}"; do ((plugin_count++)); done

    if [[ $plugin_count -gt 0 ]]; then
        # Filter out redundant entries that match project-level values
        declare -A filtered_plugins
        for plugin in "${!enabled_plugins[@]}"; do
            local our_value="${enabled_plugins[$plugin]}"
            local project_value
            project_value=$(get_project_plugin_value "$plugin")

            # Only write if:
            # 1. Value differs from project (override needed), OR
            # 2. Value is false and project is unset (explicit override of lower-priority enable)
            if [[ "$our_value" != "$project_value" ]]; then
                filtered_plugins["$plugin"]="$our_value"
            fi
            # Skip if our_value == project_value (redundant)
        done

        # Build JSON from filtered plugins
        local filtered_count=0
        for _ in "${!filtered_plugins[@]}"; do ((filtered_count++)); done

        if [[ $filtered_count -gt 0 ]]; then
            plugins_json="{"
            local first=true
            for plugin in "${!filtered_plugins[@]}"; do
                if [[ "$first" == "true" ]]; then
                    first=false
                else
                    plugins_json+=","
                fi
                plugins_json+="\"$plugin\":${filtered_plugins[$plugin]}"
            done
            plugins_json+="}"
        fi
    fi

    # Atomic update for MCPJSON servers and plugins
    local temp_file
    temp_file=$(mktemp)

    jq --argjson enabled "$enabled_json" \
       --argjson disabled "$disabled_json" \
       --argjson plugins "$plugins_json" \
       '.enabledMcpjsonServers = $enabled | .disabledMcpjsonServers = $disabled | .enabledPlugins = $plugins' \
       "$target" > "$temp_file"

    mv "$temp_file" "$target"

    # NEW: Write Direct servers to ~/.claude.json if any are disabled
    if [[ ${#disabled_direct[@]} -gt 0 ]]; then
        write_direct_servers_to_claude_json "${disabled_direct[@]}"
    else
        # Clear disabledMcpServers if no Direct servers are disabled
        write_direct_servers_to_claude_json  # Empty array
    fi
}

# ============================================================================
# DIRECT SERVER WRITE FUNCTIONS
# ============================================================================

# Write disabled Direct servers to ~/.claude.json .projects[cwd].disabledMcpServers
# Args: Array of server names to disable
# Returns: 0 on success, 1 on failure
write_direct_servers_to_claude_json() {
    local -a disabled_direct=("$@")
    local target="$HOME/.claude.json"
    local cwd=$(pwd)

    # Create timestamped backup
    local backup="$target.backup.$(date +%Y%m%d_%H%M%S)"
    if ! cp "$target" "$backup" 2>/dev/null; then
        msg_error "Failed to create backup of $target"
        return 1
    fi
    msg_info "Backup created: $backup"

    # Build disabled array JSON
    local disabled_json
    if [[ ${#disabled_direct[@]} -eq 0 ]]; then
        disabled_json="[]"
    else
        disabled_json=$(printf '%s\n' "${disabled_direct[@]}" | jq -R . | jq -s -c .)
    fi

    # Atomic update to .projects[cwd].disabledMcpServers
    local temp_file=$(mktemp)

    jq --arg cwd "$cwd" --argjson disabled "$disabled_json" \
       '.projects[$cwd].disabledMcpServers = $disabled' \
       "$target" > "$temp_file"

    # Validate JSON
    if ! jq empty "$temp_file" 2>/dev/null; then
        msg_error "JSON validation failed, rolling back"
        rm "$temp_file"
        return 1
    fi

    mv "$temp_file" "$target"
    msg_success "Updated $target (.projects[$cwd].disabledMcpServers)"

    return 0
}

# ============================================================================
# TUI GENERATION FUNCTIONS
# ============================================================================

# Generate table header with proper column alignment
# Returns: formatted header string matching the data columns
generate_table_header() {
    if [[ ! -f "$STATE_FILE" ]] || [[ ! -s "$STATE_FILE" ]]; then
        echo "  MCP Server              │  Source     │  Scope"
        return
    fi

    # Calculate same column widths as generate_fzf_list
    local max_server_len=0
    local max_type_len=0

    while IFS=: read -r state server scope file source_type; do
        [[ -z "$server" ]] && continue

        local server_len=${#server}
        local type_len=0

        if [[ "$source_type" == "direct-global" ]] || [[ "$source_type" == "direct-local" ]]; then
            type_len=6  # "direct"
        elif [[ "$source_type" == "plugin" ]]; then
            type_len=6  # "plugin"
        else
            type_len=7  # "mcpjson"
        fi

        [[ $server_len -gt $max_server_len ]] && max_server_len=$server_len
        [[ $type_len -gt $max_type_len ]] && max_type_len=$type_len
    done < "$STATE_FILE"

    # Add padding (same as generate_fzf_list)
    max_server_len=$((max_server_len + 2))
    max_type_len=$((max_type_len + 2))

    # Build header with same spacing as data rows
    local header_text="MCP Server"
    local source_text="Source"
    local scope_text="Scope"

    local server_padding=$((max_server_len - ${#header_text}))
    local type_padding=$((max_type_len - ${#source_text}))

    # Format: "  " (for symbol space) + "MCP Server" + padding + "│  " + "Source" + padding + "│  " + "Scope"
    local header="  ${header_text}"
    header+="$(printf '%*s' $server_padding '')"
    header+="│  ${source_text}"
    header+="$(printf '%*s' $type_padding '')"
    header+="│  ${scope_text}"

    echo "$header"

    # Generate separator line matching the header format
    local sep="  "
    # First column separator
    for ((i=0; i<max_server_len; i++)); do sep+="─"; done
    sep+="┼──"
    # Second column separator
    for ((i=0; i<max_type_len; i++)); do sep+="─"; done
    sep+="┼"
    # Third column separator
    for ((i=0; i<10; i++)); do sep+="─"; done

    echo "$sep"
}

# Generate fzf list from state file
# Output format: "● server-name  │  type  │  scope" with columnar alignment
generate_fzf_list() {
    if [[ ! -f "$STATE_FILE" ]] || [[ ! -s "$STATE_FILE" ]]; then
        echo ""
        return
    fi

    # First pass: calculate column widths
    local max_server_len=0
    local max_type_len=0

    while IFS=: read -r state server scope file source_type; do
        [[ -z "$server" ]] && continue

        local server_len=${#server}
        local type_len=0

        if [[ "$source_type" == "direct-global" ]] || [[ "$source_type" == "direct-local" ]]; then
            type_len=6  # "direct"
        elif [[ "$source_type" == "plugin" ]]; then
            type_len=6  # "plugin"
        else
            type_len=7  # "mcpjson"
        fi

        [[ $server_len -gt $max_server_len ]] && max_server_len=$server_len
        [[ $type_len -gt $max_type_len ]] && max_type_len=$type_len
    done < "$STATE_FILE"

    # Add padding
    max_server_len=$((max_server_len + 2))
    max_type_len=$((max_type_len + 2))

    # Second pass: format with calculated widths
    while IFS=: read -r state server scope file source_type; do
        [[ -z "$server" ]] && continue

        # Determine state symbol and color
        local symbol=""
        local symbol_color=""
        if [[ "$state" == "on" ]]; then
            symbol="●"
            symbol_color="${COLOR_GREEN}"
        else
            symbol="○"
            symbol_color="${COLOR_RED}"
        fi

        # Determine type label
        local type_label=""
        if [[ "$source_type" == "direct-global" ]] || [[ "$source_type" == "direct-local" ]]; then
            type_label="direct"
        elif [[ "$source_type" == "plugin" ]]; then
            type_label="plugin"
        else
            type_label="mcpjson"
        fi

        # Calculate padding for this row
        local server_padding=$((max_server_len - ${#server}))
        local type_padding=$((max_type_len - ${#type_label}))

        # Build row with proper spacing (avoiding printf width specs with ANSI codes)
        local row="${symbol_color}${symbol}${COLOR_RESET} "
        row+="${server}"
        row+="$(printf '%*s' $server_padding '')"
        row+="${COLOR_CYAN}│${COLOR_RESET}"
        row+="  ${type_label}"
        row+="$(printf '%*s' $type_padding '')"
        row+="${COLOR_CYAN}│${COLOR_RESET}"
        row+="  ${scope}"

        echo -e "$row"
    done < "$STATE_FILE"
}

# Helper function to output preview lines with color support
# Args: $1 - text line
# Returns: formatted line with proper color rendering
preview_line() {
    local text="$1"
    echo -e "$text"
}

# Generate preview for selected server
# Args: $1 - full line from fzf (e.g., "[ON ] server-name (scope)")
generate_preview() {
    local raw_input="$1"
    local server
    server=$(extract_server_name "$raw_input")

    if [[ -z "$server" ]]; then
        echo "No server selected"
        return
    fi

    # Find effective state, definition source, and source type from state file
    local current_state=""
    local def_scope=""
    local def_file=""
    local source_type=""

    while IFS=: read -r state srv scope file stype; do
        if [[ "$srv" == "$server" ]]; then
            current_state="$state"
            def_scope="$scope"
            def_file="$file"
            source_type="$stype"
            break
        fi
    done < "$STATE_FILE"

    if [[ -z "$current_state" ]]; then
        echo "Server not found in state"
        return
    fi

    # Get all sources for this server from raw discovery
    local all_sources
    all_sources=$(discover_and_parse_all_sources | grep ":$server:")

    # Find where server is enabled/disabled (highest priority enable/disable directive)
    local state_scope=""
    local state_file=""
    local state_priority=0

    while IFS=: read -r type srv scope file; do
        if [[ "$type" == "enable" ]] || [[ "$type" == "disable" ]]; then
            local priority
            priority=$(get_scope_priority "$scope")
            if [[ $priority -gt $state_priority ]]; then
                state_priority=$priority
                state_scope="$scope"
                state_file="$file"
            fi
        fi
    done <<< "$all_sources"

    # Add padding to align with table header in main list
    # (3 lines: 2 shortcut lines + 1 separator line before table header)
    preview_line ""
    preview_line ""
    preview_line ""

    # Box header
    preview_line "╭─────────────────────────────────────────────────╮"
    preview_line ""
    preview_line " ${COLOR_WHITE}${server}${COLOR_RESET}"
    preview_line ""

    # Direct server preview
    if [[ "$source_type" == "direct-global" ]] || [[ "$source_type" == "direct-local" ]]; then
        preview_line " ${COLOR_CYAN}Source Type${COLOR_RESET}"
        if [[ "$source_type" == "direct-global" ]]; then
            preview_line "   ${COLOR_YELLOW}Direct (global)${COLOR_RESET}"
        else
            preview_line "   ${COLOR_YELLOW}Direct (local)${COLOR_RESET}"
        fi
        preview_line ""

        preview_line " ${COLOR_CYAN}Definition${COLOR_RESET}"
        preview_line "   Scope: $def_scope"
        preview_line "   File:  $(abbreviate_path "$def_file")"
        preview_line ""

        preview_line " ${COLOR_CYAN}Status & Control${COLOR_RESET}"
        if [[ "$current_state" == "off" ]]; then
            preview_line "   ${COLOR_RED}● Disabled${COLOR_RESET} (quick-disable)"
            preview_line "   Disabled via ${COLOR_CYAN}~/.claude.json${COLOR_RESET}"
            preview_line "   Location: .projects[cwd]"
            preview_line "   Definition remains global"
            preview_line ""
            preview_line " ${COLOR_CYAN}Press SPACE to re-enable${COLOR_RESET}"
            preview_line " ${COLOR_CYAN}Press ALT-M to migrate${COLOR_RESET}"
        else
            preview_line "   ${COLOR_GREEN}● Enabled${COLOR_RESET}"
            preview_line "   In: ${COLOR_CYAN}$(abbreviate_path "$def_file")${COLOR_RESET}"
            preview_line ""
            preview_line " ${COLOR_CYAN}Press SPACE to quick-disable${COLOR_RESET}"
            preview_line " ${COLOR_CYAN}Press ALT-M to migrate${COLOR_RESET}"
        fi

        preview_line ""
        preview_line " ${COLOR_WHITE}Quick Disable${COLOR_RESET} - Modifies global"
        preview_line " ${COLOR_WHITE}Migration${COLOR_RESET} - Full project control"
        preview_line ""
        preview_line "╰─────────────────────────────────────────────────╯"
        return
    fi

    # Plugin server preview
    if [[ "$source_type" == "plugin" ]]; then
        preview_line " ${COLOR_CYAN}Source Type${COLOR_RESET}"
        preview_line "   ${COLOR_BLUE}Marketplace Plugin${COLOR_RESET}"
        preview_line ""

        preview_line " ${COLOR_CYAN}Definition${COLOR_RESET}"
        preview_line "   Scope: $def_scope"
        preview_line "   File:  $(abbreviate_path "$def_file")"
        preview_line ""

        preview_line " ${COLOR_CYAN}Status & Control${COLOR_RESET}"
        if [[ "$current_state" == "off" ]]; then
            preview_line "   ${COLOR_RED}● Disabled${COLOR_RESET}"
            if [[ -n "$state_scope" ]]; then
                preview_line "   From: ${COLOR_CYAN}$(abbreviate_path "$state_file")${COLOR_RESET}"
                preview_line "   ($state_scope)"
            fi
            preview_line "   Via ${COLOR_CYAN}enabledPlugins${COLOR_RESET}"
            preview_line "   Hidden from Claude menu"
            preview_line ""
            preview_line " ${COLOR_CYAN}Press SPACE to enable${COLOR_RESET}"
        else
            preview_line "   ${COLOR_GREEN}● Enabled${COLOR_RESET}"
            if [[ -n "$state_scope" ]]; then
                preview_line "   From: ${COLOR_CYAN}$(abbreviate_path "$state_file")${COLOR_RESET}"
                preview_line "   ($state_scope)"
            fi
            preview_line "   Via ${COLOR_CYAN}enabledPlugins${COLOR_RESET}"
            preview_line ""
            preview_line " ${COLOR_CYAN}Press SPACE to disable${COLOR_RESET}"
        fi

        preview_line ""
        preview_line " ${COLOR_YELLOW}Note:${COLOR_RESET} Delete via Claude menu"
        preview_line ""
        preview_line " Changes write to:"
        preview_line "   ./.claude/settings.local.json"
        preview_line ""
        preview_line "╰─────────────────────────────────────────────────╯"
        return
    fi

    # MCPJSON server preview
    preview_line " ${COLOR_CYAN}Source Type${COLOR_RESET}"
    preview_line "   ${COLOR_GREEN}MCP.json${COLOR_RESET} (controllable)"
    preview_line ""

    preview_line " ${COLOR_CYAN}Definition${COLOR_RESET}"
    preview_line "   Scope: $def_scope"
    preview_line "   File:  $def_file"
    preview_line ""

    preview_line " ${COLOR_CYAN}Status${COLOR_RESET}"
    if [[ "$current_state" == "on" ]]; then
        preview_line "   ${COLOR_GREEN}● Enabled${COLOR_RESET}"
    else
        preview_line "   ${COLOR_RED}● Disabled${COLOR_RESET}"
    fi
    preview_line ""

    preview_line " ${COLOR_CYAN}Press SPACE to toggle${COLOR_RESET}"
    preview_line ""

    preview_line " ${COLOR_YELLOW}Changes write to:${COLOR_RESET}"
    preview_line "   ./.claude/settings.local.json"
    preview_line ""
    preview_line "╰─────────────────────────────────────────────────╯"
}

# ============================================================================
# SERVER MANAGEMENT FLOWS
# ============================================================================

# Interactive flow to add a new server
add_server_flow() {
    # Redirect to tty to get input from user
    exec < /dev/tty

    echo ""
    echo -e "${COLOR_CYAN}Add New Server${COLOR_RESET}"
    echo ""
    read -rp "Enter server name (or press Enter to cancel): " server_name

    if [[ -z "$server_name" ]]; then
        echo "Cancelled"
        sleep 0.5
        return 0
    fi

    if add_server "$server_name"; then
        msg_success "Added $server_name"
        sleep 0.5
    else
        sleep 1
    fi
}

# Interactive flow to remove a server
# Args: $1 - server line from fzf
remove_server_flow() {
    local raw_input="$1"
    local server
    server=$(extract_server_name "$raw_input")

    if [[ -z "$server" ]]; then
        return 0
    fi

    # Redirect to tty to get input from user
    exec < /dev/tty

    echo ""
    echo -e "${COLOR_YELLOW}Remove Server: ${COLOR_WHITE}$server${COLOR_RESET}"
    echo ""
    read -rp "Are you sure? (y/N): " confirm

    if [[ "$confirm" =~ ^[Yy]$ ]]; then
        remove_server "$server"
        msg_success "Removed $server"
        sleep 0.5
    else
        echo "Cancelled"
        sleep 0.5
    fi
}

# Migration flow for Direct servers (Option B - Alternative)
# Args: $1 - server line from fzf
migrate_direct_server_flow() {
    local raw_input="$1"
    local server
    server=$(extract_server_name "$raw_input")

    if [[ -z "$server" ]]; then
        return 0
    fi

    # Check if this is a Direct server
    local source_type
    source_type=$(get_server_source_type "$server")

    if [[ "$source_type" != "direct-global" ]] && [[ "$source_type" != "direct-local" ]]; then
        # Redirect to tty for message
        exec < /dev/tty
        echo ""
        msg_warning "Migration only available for Direct servers"
        sleep 1
        return 0
    fi

    # Get definition location
    local location def_file
    location=$(get_server_definition_location "$server")
    def_file=$(echo "$location" | cut -d: -f2-)

    # Existing migration prompt and logic
    if prompt_for_migration "$server" "$source_type" "$def_file"; then
        if migrate_server_to_project_mcpjson "$server"; then
            load_servers
            msg_info "Reloaded server list - server is now controllable"
            sleep 1
        else
            msg_error "Migration failed"
            sleep 2
        fi
    fi
}

# ============================================================================
# MAIN TUI LAUNCHER
# ============================================================================

# Launch fzf TUI with all bindings and interactions
launch_fzf_tui() {
    # Export current directory and functions for fzf subshells (preview runs in different pwd)
    export MCP_CURRENT_DIR="$(pwd)"
    export STATE_FILE
    export COLOR_RESET COLOR_RED COLOR_GREEN COLOR_YELLOW COLOR_BLUE COLOR_CYAN COLOR_WHITE COLOR_ORANGE COLOR_GREY
    export MARK_ERROR MARK_SUCCESS MARK_WARNING MARK_INFO
    export -f msg_header gen_line get_term_width abbreviate_path extract_server_name
    export -f toggle_server generate_fzf_list generate_table_header add_server remove_server
    export -f enable_all_servers disable_all_servers preview_line
    export -f strip_ansi visual_width truncate_text
    export -f add_server_flow remove_server_flow migrate_direct_server_flow msg_error msg_warning msg_success msg_info
    export -f discover_and_parse_all_sources get_scope_priority generate_preview
    export -f parse_settings_file parse_mcp_json_file parse_claude_json_file detect_file_format
    export -f parse_plugin_marketplace_files parse_enabled_plugins
    export -f is_server_migrated mark_server_migrated get_server_source_type
    export -f plugin_enabled_in_lower_scope get_project_plugin_value
    export -f get_server_definition_location extract_server_definition
    export -f migrate_server_to_project_mcpjson prompt_for_migration load_servers

    clear

    # Count servers by scope
    local total_count=0
    local enabled_count=0
    local local_count=0
    local project_count=0
    local user_count=0

    if [[ -f "$STATE_FILE" ]] && [[ -s "$STATE_FILE" ]]; then
        total_count=$(wc -l < "$STATE_FILE")
        enabled_count=$(grep -c '^on:' "$STATE_FILE" 2>/dev/null || true)
        local_count=$(grep -c ':local:' "$STATE_FILE" 2>/dev/null || true)
        project_count=$(grep -c ':project:' "$STATE_FILE" 2>/dev/null || true)
        user_count=$(grep -c ':user:' "$STATE_FILE" 2>/dev/null || true)
        : ${enabled_count:=0}
        : ${local_count:=0}
        : ${project_count:=0}
        : ${user_count:=0}
    fi

    # Display ASCII art title with Claude Code orange
    echo -e "${COLOR_ORANGE}███╗   ███╗ ██████╗██████╗     ███████╗███████╗██╗     ███████╗ ██████╗████████╗ ██████╗ ██████╗${COLOR_RESET}"
    echo -e "${COLOR_ORANGE}████╗ ████║██╔════╝██╔══██╗    ██╔════╝██╔════╝██║     ██╔════╝██╔════╝╚══██╔══╝██╔═══██╗██╔══██╗${COLOR_RESET}"
    echo -e "${COLOR_ORANGE}██╔████╔██║██║     ██████╔╝    ███████╗█████╗  ██║     █████╗  ██║        ██║   ██║   ██║██████╔╝${COLOR_RESET}"
    echo -e "${COLOR_ORANGE}██║╚██╔╝██║██║     ██╔═══╝     ╚════██║██╔══╝  ██║     ██╔══╝  ██║        ██║   ██║   ██║██╔══██╗${COLOR_RESET}"
    echo -e "${COLOR_ORANGE}██║ ╚═╝ ██║╚██████╗██║         ███████║███████╗███████╗███████╗╚██████╗   ██║   ╚██████╔╝██║  ██║${COLOR_RESET}"
    echo -e "${COLOR_ORANGE}╚═╝     ╚═╝ ╚═════╝╚═╝         ╚══════╝╚══════╝╚══════╝╚══════╝ ╚═════╝   ╚═╝    ╚═════╝ ╚═╝  ╚═╝${COLOR_RESET}"
    echo ""

    # Calculate percentages
    local enabled_pct=0
    if [[ $total_count -gt 0 ]]; then
        enabled_pct=$((enabled_count * 100 / total_count))
    fi

    # Compact info bar with write target
    echo -e "${COLOR_CYAN}Write →${COLOR_RESET} ./.claude/settings.local.json  ${COLOR_WHITE}│${COLOR_RESET}  ${COLOR_GREEN}Enabled: ${enabled_count}/${total_count} (${enabled_pct}%)${COLOR_RESET}"
    echo ""

    # Generate dynamic table header that matches column widths
    local table_header
    table_header=$(generate_table_header)

    # Compact shortcuts and table header for fzf header (split into multiple lines)
    local header=""
    header="
SPACE:Toggle │ ALT-M:Migrate │ CTRL-A:Add │ CTRL-X:Delete
ALT-E:Enable All │ ALT-D:Disable All │ ENTER:Save │ ESC:Cancel

$table_header"

    # Run fzf with dynamic bindings
    set +e  # Don't exit on fzf cancel

    generate_fzf_list | fzf \
        --ansi \
        --multi \
        --reverse \
        --height=80% \
        --border=rounded \
        --prompt="  Filter: " \
        --pointer="►" \
        --marker="●" \
        --info=inline \
        --header="$header" \
        --preview="generate_preview {}" \
        --preview-window="right:45%:wrap" \
        --bind="space:execute(toggle_server {})+reload(generate_fzf_list)+refresh-preview" \
        --bind="alt-m:execute(migrate_direct_server_flow {})+reload(generate_fzf_list)+refresh-preview" \
        --bind="alt-e:execute-silent(enable_all_servers)+reload(generate_fzf_list)+refresh-preview" \
        --bind="alt-d:execute-silent(disable_all_servers)+reload(generate_fzf_list)+refresh-preview" \
        --bind="ctrl-a:execute(add_server_flow)+reload(generate_fzf_list)+refresh-preview" \
        --bind="ctrl-x:execute(remove_server_flow {})+reload(generate_fzf_list)+refresh-preview" \
        --bind="enter:accept" \
        --bind="esc:abort" \
        --color="fg:#d0d0d0,bg:#121212,hl:#5fff87" \
        --color="fg+:#ffffff,bg+:#262626,hl+:#ffff00" \
        --color="info:#af87ff,prompt:#5fff87,pointer:#ff87d7" \
        --color="marker:#00ff00,spinner:#ff87d7,header:#808080" \
        > /dev/null

    local fzf_exit=$?
    set -e

    # Handle exit code
    if [[ $fzf_exit -eq 130 ]] || [[ $fzf_exit -eq 1 ]]; then
        # User cancelled (ESC or Ctrl-C)
        clear
        msg_warning "Cancelled - no changes saved"
        return 1
    elif [[ $fzf_exit -eq 0 ]]; then
        # User confirmed
        clear
        msg_success "Saving changes..."
        save_state_to_settings

        # Show summary
        local new_enabled_count
        new_enabled_count=$(grep -c '^on:' "$STATE_FILE" 2>/dev/null || true)
        : ${new_enabled_count:=0}

        echo ""
        if [[ $new_enabled_count -eq 0 ]]; then
            msg_warning "No servers enabled"
        else
            echo -e "${COLOR_CYAN}Enabled servers (${new_enabled_count}):${COLOR_RESET}"
            while IFS=: read -r state server scope file source_type; do
                if [[ "$state" == "on" ]]; then
                    local dim='\033[2m'
                    echo -e "  ${COLOR_GREEN}${MARK_SUCCESS}${COLOR_RESET} $server ${dim}($scope, $source_type)${COLOR_RESET}"
                fi
            done < "$STATE_FILE"
        fi

        echo ""
        return 0
    else
        msg_error "Unexpected error (exit code: $fzf_exit)"
        return 1
    fi
}

# ============================================================================
# MAIN FUNCTION
# ============================================================================

main() {
    # Set up cleanup trap for state file
    STATE_FILE=$(mktemp)
    trap 'rm -f "$STATE_FILE"' EXIT

    # Check dependencies
    check_dependencies

    # Discover settings file (may trigger new project flow)
    discover_settings_file

    # Load servers into state file
    load_servers

    # Launch TUI
    if launch_fzf_tui; then
        # Success - launch Claude Code (unless in test mode)
        if [[ -n "${TEST_MODE:-}" ]]; then
            msg_success "Test mode - skipping Claude Code launch"
            exit 0
        fi

        msg_info "Launching Claude Code..."
        sleep 0.5

        # Find claude binary
        local claude_bin
        if [[ -L "$HOME/.local/bin/claude" ]]; then
            claude_bin=$(realpath_portable "$HOME/.local/bin/claude")
        elif command -v claude &> /dev/null; then
            claude_bin=$(command -v claude)
        else
            msg_error "Cannot find claude binary"
            exit 1
        fi

        exec "$claude_bin" "$@"
    else
        # User cancelled
        exit 0
    fi
}

# ============================================================================
# ENTRY POINT
# ============================================================================

main "$@"
