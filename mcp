#!/usr/bin/env bash

# MCP Server Selector v2.0
# Production-grade TUI for managing Claude Code MCP servers
# Cross-platform (Linux/macOS) - Never modifies global config

set -euo pipefail

# ============================================================================
# CONSTANTS & GLOBALS
# ============================================================================

readonly SCRIPT_NAME="$(basename "$0")"
readonly VERSION="2.1.0"

# Color codes
readonly COLOR_RESET='\033[0m'
readonly COLOR_RED='\033[0;31m'
readonly COLOR_GREEN='\033[0;32m'
readonly COLOR_YELLOW='\033[1;33m'
readonly COLOR_BLUE='\033[0;34m'
readonly COLOR_CYAN='\033[0;36m'
readonly COLOR_WHITE='\033[1m'

# Markers
readonly MARK_ERROR="✗"
readonly MARK_SUCCESS="✓"
readonly MARK_WARNING="⚠"
readonly MARK_INFO="→"

# State file (created in main, cleaned up via trap)
STATE_FILE=""

# Settings file path (determined during discovery)
SETTINGS_FILE_PATH=""
SETTINGS_SCOPE=""

# ============================================================================
# UTILITY FUNCTIONS
# ============================================================================

# Portable realpath implementation (works on Linux + macOS)
# Args: $1 - path to resolve
# Returns: absolute path
realpath_portable() {
    local path="$1"

    if [[ -d "$path" ]]; then
        (cd "$path" && pwd)
    elif [[ -e "$path" ]]; then
        local dir=$(dirname "$path")
        local base=$(basename "$path")
        (cd "$dir" && echo "$(pwd)/$base")
    else
        echo "$path"
    fi
}

# Detect operating system
# Returns: "Linux" or "Darwin" or "Unknown"
detect_os() {
    local os
    os=$(uname -s)
    echo "$os"
}

# Messaging utilities
msg_info() {
    echo -e "${COLOR_CYAN}${MARK_INFO}${COLOR_RESET} $*"
}

msg_success() {
    echo -e "${COLOR_GREEN}${MARK_SUCCESS}${COLOR_RESET} $*"
}

msg_error() {
    echo -e "${COLOR_RED}${MARK_ERROR}${COLOR_RESET} $*" >&2
}

msg_warning() {
    echo -e "${COLOR_YELLOW}${MARK_WARNING}${COLOR_RESET} $*"
}

msg_header() {
    echo -e "${COLOR_WHITE}${COLOR_CYAN}$*${COLOR_RESET}"
}

# ============================================================================
# DEPENDENCY CHECKING
# ============================================================================

# Check for required dependencies (fzf, jq)
# Exits with error if missing, provides OS-specific installation instructions
check_dependencies() {
    local missing_deps=()

    for cmd in fzf jq; do
        if ! command -v "$cmd" &> /dev/null; then
            missing_deps+=("$cmd")
        fi
    done

    if [[ ${#missing_deps[@]} -eq 0 ]]; then
        return 0
    fi

    msg_error "Missing required dependencies: ${missing_deps[*]}"
    echo ""

    local os
    os=$(detect_os)

    case "$os" in
        Linux)
            # Detect Linux package manager
            if command -v apt &> /dev/null; then
                echo -e "${COLOR_CYAN}Install with:${COLOR_RESET}"
                echo "  sudo apt update && sudo apt install ${missing_deps[*]}"
            elif command -v dnf &> /dev/null; then
                echo -e "${COLOR_CYAN}Install with:${COLOR_RESET}"
                echo "  sudo dnf install ${missing_deps[*]}"
            elif command -v yum &> /dev/null; then
                echo -e "${COLOR_CYAN}Install with:${COLOR_RESET}"
                echo "  sudo yum install ${missing_deps[*]}"
            elif command -v pacman &> /dev/null; then
                echo -e "${COLOR_CYAN}Install with:${COLOR_RESET}"
                echo "  sudo pacman -S ${missing_deps[*]}"
            else
                echo -e "${COLOR_CYAN}Install using your system's package manager${COLOR_RESET}"
            fi
            ;;
        Darwin)
            if command -v brew &> /dev/null; then
                echo -e "${COLOR_CYAN}Install with:${COLOR_RESET}"
                echo "  brew install ${missing_deps[*]}"
            else
                echo -e "${COLOR_CYAN}Install Homebrew first:${COLOR_RESET}"
                echo "  /bin/bash -c \"\$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)\""
                echo ""
                echo -e "${COLOR_CYAN}Then install dependencies:${COLOR_RESET}"
                echo "  brew install ${missing_deps[*]}"
            fi
            ;;
        *)
            echo -e "${COLOR_CYAN}Please install: ${missing_deps[*]}${COLOR_RESET}"
            ;;
    esac

    exit 1
}

# ============================================================================
# FORMAT DETECTION & PARSING
# ============================================================================

# Detect configuration file format
# Args: $1 - file path
# Returns: "mcp" or "settings" or "unknown"
detect_file_format() {
    local file="$1"

    if [[ ! -f "$file" ]]; then
        echo "unknown"
        return 1
    fi

    if ! jq empty "$file" 2>/dev/null; then
        echo "unknown"
        return 1
    fi

    # Check for mcpServers object
    if jq -e '.mcpServers' "$file" >/dev/null 2>&1; then
        echo "mcp"
        return 0
    fi

    # Check for enabledMcpjsonServers or disabledMcpjsonServers arrays
    if jq -e '.enabledMcpjsonServers' "$file" >/dev/null 2>&1 || \
       jq -e '.disabledMcpjsonServers' "$file" >/dev/null 2>&1; then
        echo "settings"
        return 0
    fi

    echo "unknown"
    return 1
}

# Get numeric priority for scope (for precedence resolution)
# Args: $1 - scope label (local/project/user)
# Returns: numeric priority (3=highest, 1=lowest)
get_scope_priority() {
    case "$1" in
        local) echo 3 ;;
        project) echo 2 ;;
        user) echo 1 ;;
        *) echo 0 ;;
    esac
}

# Parse settings file (extracts enable/disable arrays ONLY, not mcpServers definitions)
# Args: $1 - file path, $2 - scope label (local/project/user)
# Output: Lines in format "type:server:scope:file"
# Types: enable (server enabled), disable (server disabled)
# Example: enable:fetch:user:~/.claude/settings.json
parse_settings_file() {
    local file="$1"
    local scope="$2"

    if [[ ! -f "$file" ]] || ! jq empty "$file" 2>/dev/null; then
        return 0
    fi

    # Extract enabled servers
    local enabled
    enabled=$(jq -r '.enabledMcpjsonServers[]? // empty' "$file" 2>/dev/null | sort -u)

    # Extract disabled servers
    local disabled
    disabled=$(jq -r '.disabledMcpjsonServers[]? // empty' "$file" 2>/dev/null | sort -u)

    # Output enabled servers
    if [[ -n "$enabled" ]]; then
        while IFS= read -r server; do
            [[ -n "$server" ]] && echo "enable:$server:$scope:$file"
        done <<< "$enabled"
    fi

    # Output disabled servers
    if [[ -n "$disabled" ]]; then
        while IFS= read -r server; do
            [[ -n "$server" ]] && echo "disable:$server:$scope:$file"
        done <<< "$disabled"
    fi
}

# Parse .mcp.json file (mcpServers object format only, no enable/disable arrays)
# Args: $1 - file path, $2 - scope label (project only, not used for ~/.claude.json)
# Output: Lines in format "def:server:scope:file:source_type"
# Example: def:coingecko:project:./.mcp.json:mcpjson
parse_mcp_json_file() {
    local file="$1"
    local scope="$2"

    if [[ ! -f "$file" ]] || ! jq empty "$file" 2>/dev/null; then
        return 0
    fi

    # Extract server names from mcpServers object keys
    local servers
    servers=$(jq -r '.mcpServers | keys[]? // empty' "$file" 2>/dev/null | sort -u)

    if [[ -n "$servers" ]]; then
        while IFS= read -r server; do
            [[ -n "$server" ]] && echo "def:$server:$scope:$file:mcpjson"
        done <<< "$servers"
    fi
}

# Parse ~/.claude.json file (handles BOTH user and project-specific scopes)
# Args: $1 - file path (~/.claude.json)
# Output: Lines in format "type:server:scope:file:source_type"
# Types: def (server defined), enable (server enabled), disable (server disabled)
# Scopes: user (root .mcpServers), local (under .projects[cwd])
# Source types: direct-global (root), direct-local (projects)
# Example: def:fetch:user:~/.claude.json:direct-global
#          def:stripe:local:~/.claude.json:direct-local
#          enable:time:local:~/.claude.json
parse_claude_json_file() {
    local file="$1"

    if [[ ! -f "$file" ]] || ! jq empty "$file" 2>/dev/null; then
        return 0
    fi

    # Get current working directory for project matching
    local cwd
    cwd=$(pwd)

    # Parse user-scope servers (root level .mcpServers) - DIRECT-GLOBAL (always enabled)
    local user_servers
    user_servers=$(jq -r '.mcpServers | keys[]? // empty' "$file" 2>/dev/null | sort -u)

    if [[ -n "$user_servers" ]]; then
        while IFS= read -r server; do
            [[ -n "$server" ]] && echo "def:$server:user:$file:direct-global"
        done <<< "$user_servers"
    fi

    # Parse local-scope servers (project-specific .projects[cwd].mcpServers) - DIRECT-LOCAL (always enabled)
    local local_servers
    local_servers=$(jq -r --arg cwd "$cwd" '.projects[$cwd].mcpServers | keys[]? // empty' "$file" 2>/dev/null | sort -u)

    if [[ -n "$local_servers" ]]; then
        while IFS= read -r server; do
            [[ -n "$server" ]] && echo "def:$server:local:$file:direct-local"
        done <<< "$local_servers"
    fi

    # Parse local-scope enabled servers (.projects[cwd].enabledMcpjsonServers)
    # NOTE: These are removed by Claude Code on launch, but we parse them for completeness
    local enabled
    enabled=$(jq -r --arg cwd "$cwd" '.projects[$cwd].enabledMcpjsonServers[]? // empty' "$file" 2>/dev/null | sort -u)

    if [[ -n "$enabled" ]]; then
        while IFS= read -r server; do
            [[ -n "$server" ]] && echo "enable:$server:local:$file"
        done <<< "$enabled"
    fi

    # Parse local-scope disabled servers (.projects[cwd].disabledMcpjsonServers)
    # NOTE: These are removed by Claude Code on launch, but we parse them for completeness
    local disabled
    disabled=$(jq -r --arg cwd "$cwd" '.projects[$cwd].disabledMcpjsonServers[]? // empty' "$file" 2>/dev/null | sort -u)

    if [[ -n "$disabled" ]]; then
        while IFS= read -r server; do
            [[ -n "$server" ]] && echo "disable:$server:local:$file"
        done <<< "$disabled"
    fi
}

# ============================================================================
# CONFIGURATION DISCOVERY & NEW PROJECT FLOW
# ============================================================================

# Check for configuration and handle new project flow if needed
# No longer sets SETTINGS_FILE_PATH or SETTINGS_SCOPE (multi-source approach)
discover_settings_file() {
    local current_dir
    current_dir=$(pwd)

    # Check if any local config exists
    if [[ -f "$current_dir/.claude/settings.local.json" ]] || \
       [[ -f "$current_dir/.claude/settings.json" ]] || \
       [[ -f "$current_dir/.mcp.json" ]]; then
        # Local config exists, proceed normally
        return 0
    fi

    # No local config, check if global exists
    if [[ -f "$HOME/.claude/settings.json" ]] || \
       [[ -f "$HOME/.claude/settings.local.json" ]] || \
       [[ -f "$HOME/.claude.json" ]]; then
        # Global config exists, trigger new project flow
        handle_new_project_prompt
        return $?
    fi

    # No configuration found anywhere
    msg_error "No Claude configuration found (local or global)"
    echo ""
    echo "Please configure Claude first by running 'claude' once."
    exit 1
}

# Handle new project initialization flow
# Prompts user to create local config or use global
handle_new_project_prompt() {
    clear
    msg_header "New Project Detected"
    echo ""
    echo "You are in a directory without a local Claude configuration."
    echo "Global configuration will be used as a template."
    echo ""
    echo "What would you like to do?"
    echo ""
    echo "  ${COLOR_GREEN}1)${COLOR_RESET} Create local configuration (.claude/settings.local.json) for this project ${COLOR_CYAN}(Recommended)${COLOR_RESET}"
    echo "  ${COLOR_YELLOW}2)${COLOR_RESET} Continue with global settings only (changes will still be saved to local)"
    echo "  ${COLOR_RED}3)${COLOR_RESET} Abort"
    echo ""

    local choice
    read -rp "Enter your choice [1-3]: " choice

    case "$choice" in
        1)
            # Create local config from global template
            msg_info "Creating local configuration..."
            mkdir -p ./.claude

            # Find global settings file to use as template
            local template=""
            if [[ -f "$HOME/.claude/settings.json" ]]; then
                template="$HOME/.claude/settings.json"
            elif [[ -f "$HOME/.claude/settings.local.json" ]]; then
                template="$HOME/.claude/settings.local.json"
            elif [[ -f "$HOME/.claude.json" ]]; then
                template="$HOME/.claude.json"
            else
                # Create empty settings
                echo '{}' > "./.claude/settings.local.json"
                msg_success "Created empty ./.claude/settings.local.json"
                echo ""
                return 0
            fi

            cp "$template" "./.claude/settings.local.json"
            msg_success "Created ./.claude/settings.local.json from $template"
            echo ""
            return 0
            ;;
        2)
            # Continue without creating local config
            # Changes will still be saved to .claude/settings.local.json when user confirms
            msg_info "Continuing with global settings..."
            echo ""
            return 0
            ;;
        3|*)
            # Abort
            msg_warning "Operation cancelled"
            exit 0
            ;;
    esac
}

# ============================================================================
# STATE MANAGEMENT
# ============================================================================

# Discover and parse all configuration sources
# mcpServers definitions can exist in:
#   - ~/.claude.json (user-scope root & project-scope .projects[cwd]) - DIRECT (always enabled)
#   - ~/.mcp.json (user-scope) - MCPJSON (controllable)
#   - ./.mcp.json (project-scope) - MCPJSON (controllable)
# Enable/disable arrays ONLY work for MCPJSON servers (from .mcp.json files)
# Output: Lines in format "type:server:scope:file:source_type"
discover_and_parse_all_sources() {
    local temp_raw
    temp_raw=$(mktemp)

    # Parse ~/.claude.json (handles both user-scope root AND local-scope project entries)
    # Also extracts enable/disable arrays from .projects[cwd] (though Claude Code removes them)
    parse_claude_json_file "$HOME/.claude.json" >> "$temp_raw"

    # Parse ~/.mcp.json (user-scope mcpServers - MCPJSON type, controllable)
    parse_mcp_json_file "$HOME/.mcp.json" "user" >> "$temp_raw"

    # Parse ./.mcp.json (project-scope mcpServers - MCPJSON type, controllable)
    parse_mcp_json_file "./.mcp.json" "project" >> "$temp_raw"

    # Parse enable/disable arrays from all settings files (reverse precedence order)
    # User scope (lowest priority)
    parse_settings_file "$HOME/.claude/settings.json" "user" >> "$temp_raw"
    parse_settings_file "$HOME/.claude/settings.local.json" "user" >> "$temp_raw"

    # Project scope
    parse_settings_file "./.claude/settings.json" "project" >> "$temp_raw"

    # Local scope (highest priority)
    parse_settings_file "./.claude/settings.local.json" "local" >> "$temp_raw"

    cat "$temp_raw"
    rm -f "$temp_raw"
}

# Load servers from all sources with DUAL precedence resolution
# Separates server definitions from enable/disable state
# State format: "state:server:def_scope:def_file:source_type" (one per line)
# Example: "on:fetch:project:./.mcp.json:mcpjson"
# Where state=on/off, def_scope/def_file=where server is DEFINED, source_type=mcpjson/direct-global/direct-local
load_servers() {
    local raw_data
    raw_data=$(discover_and_parse_all_sources)

    if [[ -z "$raw_data" ]]; then
        msg_warning "No MCP servers found in any configuration file"
        echo ""
        msg_info "You can add servers using Ctrl-A in the TUI"
        echo ""
        touch "$STATE_FILE"
        return 0
    fi

    # Build two separate maps for dual precedence resolution
    # Map 1: Server definitions (where server is configured)
    # Key: server_name, Value: priority:scope:file:source_type
    declare -A server_definitions

    # Map 2: Enable/disable state (whether server is active)
    # Key: server_name, Value: priority:state (on/off)
    declare -A server_states

    # Parse raw data and populate both maps
    while IFS=: read -r type server scope file source_type; do
        [[ -z "$server" ]] && continue

        local priority
        priority=$(get_scope_priority "$scope")

        if [[ "$type" == "def" ]]; then
            # This is a server definition
            local new_value="$priority:$scope:$file:$source_type"

            if [[ -n "${server_definitions[$server]:-}" ]]; then
                local existing_priority
                existing_priority=$(echo "${server_definitions[$server]}" | cut -d: -f1)

                # Higher priority wins (3 > 2 > 1)
                if [[ $priority -gt $existing_priority ]]; then
                    server_definitions[$server]="$new_value"
                fi
            else
                server_definitions[$server]="$new_value"
            fi

        elif [[ "$type" == "enable" ]]; then
            # This is an enable directive
            local new_value="$priority:on"

            if [[ -n "${server_states[$server]:-}" ]]; then
                local existing_priority
                existing_priority=$(echo "${server_states[$server]}" | cut -d: -f1)

                if [[ $priority -gt $existing_priority ]]; then
                    server_states[$server]="$new_value"
                fi
            else
                server_states[$server]="$new_value"
            fi

        elif [[ "$type" == "disable" ]]; then
            # This is a disable directive
            local new_value="$priority:off"

            if [[ -n "${server_states[$server]:-}" ]]; then
                local existing_priority
                existing_priority=$(echo "${server_states[$server]}" | cut -d: -f1)

                if [[ $priority -gt $existing_priority ]]; then
                    server_states[$server]="$new_value"
                fi
            else
                server_states[$server]="$new_value"
            fi
        fi
    done <<< "$raw_data"

    # Write to state file
    > "$STATE_FILE"  # Truncate

    # Merge: For each defined server, attach its state and source type
    for server in "${!server_definitions[@]}"; do
        local def_value="${server_definitions[$server]}"
        # Extract scope:file:source_type from priority:scope:file:source_type
        local def_scope def_file source_type
        def_scope=$(echo "$def_value" | cut -d: -f2)
        def_file=$(echo "$def_value" | cut -d: -f3)
        source_type=$(echo "$def_value" | cut -d: -f4)

        # Get state (default to "on" if not mentioned in any enable/disable array)
        # MCPJSON servers are enabled by default unless explicitly disabled
        # DIRECT servers are ALWAYS enabled (but we track state for migration purposes)
        local state="on"
        if [[ -n "${server_states[$server]:-}" ]]; then
            local state_value="${server_states[$server]}"
            state=$(echo "$state_value" | cut -d: -f2)
        fi

        echo "$state:$server:$def_scope:$def_file:$source_type" >> "$STATE_FILE"
    done

    # Sort state file by server name
    sort -t: -k2 "$STATE_FILE" -o "$STATE_FILE"
}

# ============================================================================
# MIGRATION HELPER FUNCTIONS
# ============================================================================

# Check if server has already been migrated to ./.mcp.json
# Args: $1 - server name
# Returns: 0 if migrated, 1 if not
is_server_migrated() {
    local server="$1"
    local migrations_file="./.claude/.mcp_migrations"

    if [[ -f "$migrations_file" ]]; then
        grep -q "^$server:" "$migrations_file" 2>/dev/null
        return $?
    fi

    return 1
}

# Mark server as migrated
# Args: $1 - server name
mark_server_migrated() {
    local server="$1"
    local migrations_file="./.claude/.mcp_migrations"

    mkdir -p "./.claude"
    echo "$server:$(date +%s)" >> "$migrations_file"
}

# Get server source type from state file
# Args: $1 - server name
# Returns: source type (mcpjson, direct-global, direct-local) or empty
get_server_source_type() {
    local server="$1"

    while IFS=: read -r state srv scope file source_type; do
        if [[ "$srv" == "$server" ]]; then
            echo "$source_type"
            return 0
        fi
    done < "$STATE_FILE"

    return 1
}

# Get server definition file and scope from state file
# Args: $1 - server name
# Returns: "scope:file" or empty
get_server_definition_location() {
    local server="$1"

    while IFS=: read -r state srv scope file source_type; do
        if [[ "$srv" == "$server" ]]; then
            echo "$scope:$file"
            return 0
        fi
    done < "$STATE_FILE"

    return 1
}

# Extract server definition from source file
# Args: $1 - server name, $2 - source file, $3 - source type
# Returns: JSON definition of server
extract_server_definition() {
    local server="$1"
    local source_file="$2"
    local source_type="$3"
    local cwd=$(pwd)

    if [[ "$source_type" == "direct-global" ]]; then
        # From ~/.claude.json root .mcpServers
        jq -r --arg srv "$server" '.mcpServers[$srv]' "$source_file"
    elif [[ "$source_type" == "direct-local" ]]; then
        # From ~/.claude.json .projects[cwd].mcpServers
        jq -r --arg cwd "$cwd" --arg srv "$server" '.projects[$cwd].mcpServers[$srv]' "$source_file"
    else
        # From .mcp.json file
        jq -r --arg srv "$server" '.mcpServers[$srv]' "$source_file"
    fi
}

# Migrate server from ~/.claude.json to ./.mcp.json
# Args: $1 - server name
# Returns: 0 on success, 1 on failure
migrate_server_to_project_mcpjson() {
    local server="$1"

    # Get server location and source type
    local location source_type def_scope def_file
    location=$(get_server_definition_location "$server")
    if [[ -z "$location" ]]; then
        msg_error "Cannot find server '$server' in state"
        return 1
    fi

    def_scope=$(echo "$location" | cut -d: -f1)
    def_file=$(echo "$location" | cut -d: -f2-)
    source_type=$(get_server_source_type "$server")

    # Only migrate if it's a direct server
    if [[ "$source_type" != "direct-global" ]] && [[ "$source_type" != "direct-local" ]]; then
        msg_error "Server '$server' is not a direct server (type: $source_type)"
        return 1
    fi

    msg_info "Migrating '$server' to ./.mcp.json for project-level control..."
    echo ""

    # Create backup of ~/.claude.json
    local backup_file="$HOME/.claude.json.backup.$(date +%Y%m%d_%H%M%S)"
    if ! cp "$def_file" "$backup_file" 2>/dev/null; then
        msg_error "Failed to create backup of $def_file"
        return 1
    fi
    msg_info "Backup created: $backup_file"

    # Extract server definition
    local definition
    definition=$(extract_server_definition "$server" "$def_file" "$source_type")
    if [[ -z "$definition" ]] || [[ "$definition" == "null" ]]; then
        msg_error "Failed to extract server definition"
        rm "$backup_file"
        return 1
    fi

    # Create ./.mcp.json if it doesn't exist
    if [[ ! -f "./.mcp.json" ]]; then
        echo '{"mcpServers":{}}' > "./.mcp.json"
        msg_info "Created ./.mcp.json"
    fi

    # Add to ./.mcp.json (atomic operation)
    local temp_dest=$(mktemp)
    if ! jq --arg srv "$server" --argjson def "$definition" \
        '.mcpServers[$srv] = $def' "./.mcp.json" > "$temp_dest" 2>/dev/null; then
        msg_error "Failed to add server to ./.mcp.json"
        rm "$temp_dest" "$backup_file"
        return 1
    fi
    mv "$temp_dest" "./.mcp.json"
    msg_success "Added to ./.mcp.json"

    # Remove from ~/.claude.json (atomic operation)
    local temp_src=$(mktemp)
    local cwd=$(pwd)

    if [[ "$source_type" == "direct-global" ]]; then
        # Remove from root .mcpServers
        if ! jq --arg srv "$server" 'del(.mcpServers[$srv])' "$def_file" > "$temp_src" 2>/dev/null; then
            msg_error "Failed to remove server from $def_file"
            rm "$temp_src" "$backup_file"
            return 1
        fi
    elif [[ "$source_type" == "direct-local" ]]; then
        # Remove from .projects[cwd].mcpServers
        if ! jq --arg cwd "$cwd" --arg srv "$server" \
            'del(.projects[$cwd].mcpServers[$srv])' "$def_file" > "$temp_src" 2>/dev/null; then
            msg_error "Failed to remove server from $def_file"
            rm "$temp_src" "$backup_file"
            return 1
        fi
    fi

    # Validate both JSON files
    if ! jq empty "$temp_src" 2>/dev/null || ! jq empty "./.mcp.json" 2>/dev/null; then
        msg_error "JSON validation failed, rolling back"
        mv "$backup_file" "$def_file"
        rm "$temp_src"
        return 1
    fi

    mv "$temp_src" "$def_file"
    msg_success "Removed from $def_file"

    # Mark as migrated
    mark_server_migrated "$server"

    echo ""
    msg_success "Migration complete!"
    msg_info "Server '$server' can now be controlled via project settings"
    echo ""

    return 0
}

# Prompt user for migration with interactive options
# Args: $1 - server name, $2 - source type, $3 - source file
# Returns: 0 if user wants to migrate, 1 if not
prompt_for_migration() {
    local server="$1"
    local source_type="$2"
    local source_file="$3"

    # Redirect to tty to get input from user
    exec < /dev/tty

    clear
    echo ""
    echo -e "${COLOR_YELLOW}═══════════════════════════════════════════════════${COLOR_RESET}"
    echo -e "${COLOR_WHITE}  Migration Required: ${COLOR_CYAN}$server${COLOR_RESET}"
    echo -e "${COLOR_YELLOW}═══════════════════════════════════════════════════${COLOR_RESET}"
    echo ""
    echo "This server is defined in:"
    echo -e "  ${COLOR_CYAN}$source_file${COLOR_RESET}"
    echo ""
    echo "Servers in this location are ${COLOR_RED}ALWAYS ENABLED${COLOR_RESET}."
    echo ""
    echo "To disable it, this tool must:"
    echo -e "  ${COLOR_GREEN}1.${COLOR_RESET} MOVE definition → ${COLOR_CYAN}./.mcp.json${COLOR_RESET} (project)"
    echo -e "  ${COLOR_GREEN}2.${COLOR_RESET} REMOVE from → ${COLOR_CYAN}$source_file${COLOR_RESET}"
    echo -e "  ${COLOR_GREEN}3.${COLOR_RESET} Disable via → ${COLOR_CYAN}./.claude/settings.local.json${COLOR_RESET}"
    echo ""
    echo -e "${COLOR_YELLOW}⚠ This MODIFIES your global config!${COLOR_RESET}"
    echo -e "  (A timestamped backup will be created first)"
    echo ""
    echo -e "${COLOR_WHITE}What would you like to do?${COLOR_RESET}"
    echo ""
    echo -e "  ${COLOR_GREEN}[y] Yes - Migrate and disable${COLOR_RESET}"
    echo "      • Performs all 3 steps above automatically"
    echo "      • Server becomes controllable in this project"
    echo "      • Server will be DISABLED after migration"
    echo "      • Global config is modified (backup created)"
    echo "      • ${COLOR_CYAN}Recommended if you want project-level control${COLOR_RESET}"
    echo ""
    echo -e "  ${COLOR_BLUE}[v] View - Show server definition${COLOR_RESET}"
    echo "      • Displays the full JSON configuration"
    echo "      • Helps you understand what will be migrated"
    echo "      • You can decide after viewing"
    echo "      • No changes made until you confirm"
    echo ""
    echo -e "  ${COLOR_RED}[n] No - Keep enabled globally${COLOR_RESET}"
    echo "      • Cancels migration process"
    echo "      • Server remains in $source_file"
    echo "      • Server stays ALWAYS ENABLED"
    echo "      • No changes made to any files"
    echo ""

    while true; do
        read -rp "Your choice [y/v/n]: " choice
        case "$choice" in
            y|Y)
                return 0
                ;;
            v|V)
                # Show definition
                echo ""
                echo -e "${COLOR_CYAN}Server Definition:${COLOR_RESET}"
                echo ""
                extract_server_definition "$server" "$source_file" "$source_type" | jq .
                echo ""
                read -rp "Migrate this to ./.mcp.json? [y/n]: " confirm
                if [[ "$confirm" =~ ^[Yy]$ ]]; then
                    return 0
                else
                    return 1
                fi
                ;;
            n|N)
                msg_warning "Migration cancelled - server will remain enabled"
                sleep 1
                return 1
                ;;
            *)
                echo -e "${COLOR_RED}Invalid choice. Please enter y, v, or n${COLOR_RESET}"
                ;;
        esac
    done
}

# Toggle server state in state file
# Args: $1 - server name (may have prefix like "[ON ] server-name (scope)")
# Handles migration for direct servers
toggle_server() {
    local raw_input="$1"

    # Strip ANSI codes, prefixes, and scope suffix to get clean server name
    local server
    server=$(echo "$raw_input" | sed 's/\x1b\[[0-9;]*m//g' | sed 's/^\[ON \] *//' | sed 's/^\[OFF\] *//' | sed 's/^\[⚠ \] *//' | sed 's/^     *//' | sed 's/ *(.*)$//')

    # Get source type and current state
    local source_type current_state
    source_type=$(get_server_source_type "$server")

    while IFS=: read -r state srv scope file stype; do
        if [[ "$srv" == "$server" ]]; then
            current_state="$state"
            break
        fi
    done < "$STATE_FILE"

    # Check if this is a direct server and user is trying to disable it
    if [[ "$source_type" == "direct-global" ]] || [[ "$source_type" == "direct-local" ]]; then
        # Check if server is currently enabled and user wants to disable
        if [[ "$current_state" == "on" ]]; then
            # Check if already migrated
            if ! is_server_migrated "$server"; then
                # Get definition location
                local location def_file
                location=$(get_server_definition_location "$server")
                def_file=$(echo "$location" | cut -d: -f2-)

                # Prompt for migration
                if prompt_for_migration "$server" "$source_type" "$def_file"; then
                    # Perform migration
                    if migrate_server_to_project_mcpjson "$server"; then
                        # Reload servers after migration
                        load_servers
                        msg_info "Reloaded server list - server is now controllable"
                        sleep 1
                        return 0
                    else
                        msg_error "Migration failed"
                        sleep 2
                        return 1
                    fi
                else
                    # User cancelled migration
                    return 0
                fi
            fi
            # If already migrated, fall through to normal toggle
        fi
    fi

    # Normal toggle (for mcpjson servers or re-enabling direct servers after migration)
    local temp_state
    temp_state=$(mktemp)

    while IFS=: read -r state srv scope file source_type; do
        if [[ "$srv" == "$server" ]]; then
            # Toggle state, preserve scope, file, and source type
            if [[ "$state" == "on" ]]; then
                echo "off:$srv:$scope:$file:$source_type" >> "$temp_state"
            else
                echo "on:$srv:$scope:$file:$source_type" >> "$temp_state"
            fi
        else
            # Keep unchanged
            echo "$state:$srv:$scope:$file:$source_type" >> "$temp_state"
        fi
    done < "$STATE_FILE"

    mv "$temp_state" "$STATE_FILE"
}

# Add new server to state file (disabled by default, local scope, mcpjson type)
# Args: $1 - server name
# Note: Added servers are placeholders - user must define them in .mcp.json manually
add_server() {
    local server="$1"

    # Validate server name (alphanumeric, dashes, underscores)
    if [[ ! "$server" =~ ^[a-zA-Z0-9_-]+$ ]]; then
        msg_error "Invalid server name. Use only alphanumeric characters, dashes, and underscores."
        return 1
    fi

    # Check for duplicates (check column 2 for server name)
    if grep -q "^[^:]*:$server:" "$STATE_FILE" 2>/dev/null; then
        msg_warning "Server '$server' already exists"
        return 1
    fi

    # Add to state file (disabled, project scope, .mcp.json, mcpjson type)
    # Note: This assumes user will define the server in ./.mcp.json
    echo "off:$server:project:./.mcp.json:mcpjson" >> "$STATE_FILE"
    sort -t: -k2 "$STATE_FILE" -o "$STATE_FILE"
}

# Remove server from state file
# Args: $1 - server name (may have prefix and scope suffix)
remove_server() {
    local raw_input="$1"

    # Strip ANSI codes, prefixes, and scope suffix
    local server
    server=$(echo "$raw_input" | sed 's/\x1b\[[0-9;]*m//g' | sed 's/^\[ON \] *//' | sed 's/^\[OFF\] *//' | sed 's/^\[⚠ \] *//' | sed 's/^     *//' | sed 's/ *(.*)$//')

    # Remove from state file (match server name in column 2)
    local temp_state
    temp_state=$(mktemp)

    while IFS=: read -r state srv scope file source_type; do
        if [[ "$srv" != "$server" ]]; then
            echo "$state:$srv:$scope:$file:$source_type" >> "$temp_state"
        fi
    done < "$STATE_FILE"

    mv "$temp_state" "$STATE_FILE"
}

# Enable all servers in state file (preserve scope, file, and source type metadata)
enable_all_servers() {
    local temp_state
    temp_state=$(mktemp)

    while IFS=: read -r state srv scope file source_type; do
        echo "on:$srv:$scope:$file:$source_type" >> "$temp_state"
    done < "$STATE_FILE"

    mv "$temp_state" "$STATE_FILE"
}

# Disable all servers in state file (preserve scope, file, and source type metadata)
disable_all_servers() {
    local temp_state
    temp_state=$(mktemp)

    while IFS=: read -r state srv scope file source_type; do
        echo "off:$srv:$scope:$file:$source_type" >> "$temp_state"
    done < "$STATE_FILE"

    mv "$temp_state" "$STATE_FILE"
}

# Save state file to project-local settings only (./.claude/settings.local.json)
# Never modifies global user settings
save_state_to_settings() {
    local target="./.claude/settings.local.json"

    # Create .claude directory if it doesn't exist
    if [[ ! -d "./.claude" ]]; then
        mkdir -p "./.claude"
        msg_info "Created .claude/ directory"
    fi

    # Parse state file into enabled and disabled arrays (server names only)
    local enabled_servers=()
    local disabled_servers=()

    while IFS=: read -r state server scope file source_type; do
        [[ -z "$server" ]] && continue

        if [[ "$state" == "on" ]]; then
            enabled_servers+=("$server")
        elif [[ "$state" == "off" ]]; then
            disabled_servers+=("$server")
        fi
    done < "$STATE_FILE"

    # Build JSON arrays
    local enabled_json
    local disabled_json

    if [[ ${#enabled_servers[@]} -eq 0 ]]; then
        enabled_json="[]"
    else
        enabled_json=$(printf '%s\n' "${enabled_servers[@]}" | jq -R . | jq -s -c .)
    fi

    if [[ ${#disabled_servers[@]} -eq 0 ]]; then
        disabled_json="[]"
    else
        disabled_json=$(printf '%s\n' "${disabled_servers[@]}" | jq -R . | jq -s -c .)
    fi

    # Initialize with empty object if file doesn't exist
    if [[ ! -f "$target" ]]; then
        echo '{}' > "$target"
        msg_info "Created $target"
    fi

    # Atomic update using temp file (merge with existing settings)
    local temp_file
    temp_file=$(mktemp)

    jq --argjson enabled "$enabled_json" \
       --argjson disabled "$disabled_json" \
       '.enabledMcpjsonServers = $enabled | .disabledMcpjsonServers = $disabled' \
       "$target" > "$temp_file"

    mv "$temp_file" "$target"
}

# ============================================================================
# TUI GENERATION FUNCTIONS
# ============================================================================

# Generate fzf list from state file
# Output format: "[ON ] server-name (scope, type)" or "[⚠ ] server-name (scope, always-on)"
generate_fzf_list() {
    if [[ ! -f "$STATE_FILE" ]] || [[ ! -s "$STATE_FILE" ]]; then
        echo ""
        return
    fi

    local dim='\033[2m'  # Dim/grey color for scope labels
    local warning_color='\033[0;33m'  # Yellow for warning

    while IFS=: read -r state server scope file source_type; do
        [[ -z "$server" ]] && continue

        # Check if server is a direct server (always enabled) and not yet migrated
        local is_direct=false
        if [[ "$source_type" == "direct-global" ]] || [[ "$source_type" == "direct-local" ]]; then
            if ! is_server_migrated "$server"; then
                is_direct=true
            fi
        fi

        if [[ "$is_direct" == "true" ]]; then
            # Direct servers show warning indicator
            echo -e "${warning_color}[⚠ ]${COLOR_RESET} $server ${dim}($scope, always-on)${COLOR_RESET}"
        elif [[ "$state" == "on" ]]; then
            echo -e "${COLOR_GREEN}[ON ]${COLOR_RESET} $server ${dim}($scope, $source_type)${COLOR_RESET}"
        elif [[ "$state" == "off" ]]; then
            echo -e "${COLOR_RED}[OFF]${COLOR_RESET} $server ${dim}($scope, $source_type)${COLOR_RESET}"
        fi
    done < "$STATE_FILE"
}

# Generate preview for selected server
# Args: $1 - full line from fzf (e.g., "[ON ] server-name (scope)")
generate_preview() {
    local raw_input="$1"

    # Strip ANSI codes, prefixes, and scope suffix
    local server
    server=$(echo "$raw_input" | sed 's/\x1b\[[0-9;]*m//g' | sed 's/^\[ON \] *//' | sed 's/^\[OFF\] *//' | sed 's/^\[⚠ \] *//' | sed 's/^     *//' | sed 's/ *(.*)$//')

    if [[ -z "$server" ]]; then
        echo "No server selected"
        return
    fi

    # Find effective state, definition source, and source type from state file
    local current_state=""
    local def_scope=""
    local def_file=""
    local source_type=""

    while IFS=: read -r state srv scope file stype; do
        if [[ "$srv" == "$server" ]]; then
            current_state="$state"
            def_scope="$scope"
            def_file="$file"
            source_type="$stype"
            break
        fi
    done < "$STATE_FILE"

    if [[ -z "$current_state" ]]; then
        echo "Server not found in state"
        return
    fi

    # Get all sources for this server from raw discovery
    local all_sources
    all_sources=$(discover_and_parse_all_sources | grep ":$server:")

    # Find where server is enabled/disabled (highest priority enable/disable directive)
    local state_scope=""
    local state_file=""
    local state_priority=0

    while IFS=: read -r type srv scope file; do
        if [[ "$type" == "enable" ]] || [[ "$type" == "disable" ]]; then
            local priority
            priority=$(get_scope_priority "$scope")
            if [[ $priority -gt $state_priority ]]; then
                state_priority=$priority
                state_scope="$scope"
                state_file="$file"
            fi
        fi
    done <<< "$all_sources"

    # Header with separator
    echo "────────────────────────────────────────"
    echo -e " ${COLOR_WHITE}$server${COLOR_RESET}"
    echo "────────────────────────────────────────"
    echo ""

    # Source type
    echo -e "${COLOR_CYAN}Source Type${COLOR_RESET}"
    case "$source_type" in
        mcpjson)
            echo -e "  ${COLOR_GREEN}MCP.json${COLOR_RESET} (controllable)"
            ;;
        direct-global)
            echo -e "  ${COLOR_YELLOW}Direct (global)${COLOR_RESET} - always enabled"
            ;;
        direct-local)
            echo -e "  ${COLOR_YELLOW}Direct (local)${COLOR_RESET} - always enabled"
            ;;
    esac
    echo ""

    # Definition source
    echo -e "${COLOR_CYAN}Definition${COLOR_RESET}"
    echo -e "  Scope: $def_scope"
    echo -e "  File:  $def_file"
    echo ""

    # Status
    echo -e "${COLOR_CYAN}Status${COLOR_RESET}"

    # Check if this is a direct server that hasn't been migrated
    if [[ "$source_type" == "direct-global" ]] || [[ "$source_type" == "direct-local" ]]; then
        if ! is_server_migrated "$server"; then
            # Direct server - always enabled
            echo -e "  ${COLOR_YELLOW}⚠  Always Enabled${COLOR_RESET}"
            echo ""
            echo -e "${COLOR_YELLOW}═══════════════════════════════════════${COLOR_RESET}"
            echo -e "${COLOR_WHITE}Cannot be disabled in current location${COLOR_RESET}"
            echo -e "${COLOR_YELLOW}═══════════════════════════════════════${COLOR_RESET}"
            echo ""
            echo "To enable project-level control:"
            echo -e "  Press ${COLOR_CYAN}SPACE${COLOR_RESET} to migrate to ./.mcp.json"
            echo ""
            echo "Migration will:"
            echo -e "  ${COLOR_GREEN}•${COLOR_RESET} Move definition to ./.mcp.json"
            echo -e "  ${COLOR_GREEN}•${COLOR_RESET} Remove from $def_file"
            echo -e "  ${COLOR_GREEN}•${COLOR_RESET} Enable disable/enable toggling"
            echo -e "  ${COLOR_YELLOW}•${COLOR_RESET} Backup created automatically"
            echo ""
            echo "────────────────────────────────────────"
            echo -e "Press ${COLOR_CYAN}SPACE${COLOR_RESET} to migrate and disable"
            return
        else
            # Direct server that has been migrated
            if [[ "$current_state" == "on" ]]; then
                echo -e "  ${COLOR_GREEN}Enabled${COLOR_RESET} (migrated)"
            else
                echo -e "  ${COLOR_RED}Disabled${COLOR_RESET} (migrated)"
            fi
        fi
    else
        # MCPJSON server - normal controllable server
        if [[ "$current_state" == "on" ]]; then
            echo -e "  ${COLOR_GREEN}Enabled${COLOR_RESET}"
        else
            echo -e "  ${COLOR_RED}Disabled${COLOR_RESET}"
        fi
    fi
    echo ""

    # Write target
    echo "────────────────────────────────────────"
    echo -e "${COLOR_YELLOW}Changes write to:${COLOR_RESET}"
    echo "  ./.claude/settings.local.json"
    echo "────────────────────────────────────────"
    echo ""
    echo -e "Press ${COLOR_CYAN}SPACE${COLOR_RESET} to toggle"
}

# ============================================================================
# SERVER MANAGEMENT FLOWS
# ============================================================================

# Interactive flow to add a new server
add_server_flow() {
    # Redirect to tty to get input from user
    exec < /dev/tty

    echo ""
    echo -e "${COLOR_CYAN}Add New Server${COLOR_RESET}"
    echo ""
    read -rp "Enter server name (or press Enter to cancel): " server_name

    if [[ -z "$server_name" ]]; then
        echo "Cancelled"
        sleep 0.5
        return 0
    fi

    if add_server "$server_name"; then
        msg_success "Added $server_name"
        sleep 0.5
    else
        sleep 1
    fi
}

# Interactive flow to remove a server
# Args: $1 - server line from fzf
remove_server_flow() {
    local raw_input="$1"

    # Strip to get server name
    local server
    server=$(echo "$raw_input" | sed 's/\x1b\[[0-9;]*m//g' | sed 's/^\[ON \] *//' | sed 's/^\[OFF\] *//' | sed 's/^     *//')

    if [[ -z "$server" ]]; then
        return 0
    fi

    # Redirect to tty to get input from user
    exec < /dev/tty

    echo ""
    echo -e "${COLOR_YELLOW}Remove Server: ${COLOR_WHITE}$server${COLOR_RESET}"
    echo ""
    read -rp "Are you sure? (y/N): " confirm

    if [[ "$confirm" =~ ^[Yy]$ ]]; then
        remove_server "$server"
        msg_success "Removed $server"
        sleep 0.5
    else
        echo "Cancelled"
        sleep 0.5
    fi
}

# ============================================================================
# MAIN TUI LAUNCHER
# ============================================================================

# Launch fzf TUI with all bindings and interactions
launch_fzf_tui() {
    # Export functions and variables for fzf subshells
    export STATE_FILE
    export COLOR_RESET COLOR_RED COLOR_GREEN COLOR_YELLOW COLOR_BLUE COLOR_CYAN COLOR_WHITE
    export MARK_ERROR MARK_SUCCESS MARK_WARNING MARK_INFO
    export -f msg_header
    export -f toggle_server generate_fzf_list add_server remove_server
    export -f enable_all_servers disable_all_servers
    export -f add_server_flow remove_server_flow msg_error msg_warning msg_success msg_info
    export -f discover_and_parse_all_sources get_scope_priority generate_preview
    export -f parse_settings_file parse_mcp_json_file parse_claude_json_file detect_file_format
    export -f is_server_migrated mark_server_migrated get_server_source_type
    export -f get_server_definition_location extract_server_definition
    export -f migrate_server_to_project_mcpjson prompt_for_migration load_servers

    clear
    msg_header "MCP Server Selector v${VERSION}"
    echo -e "${COLOR_YELLOW}Write Target:${COLOR_RESET} ./.claude/settings.local.json"
    echo -e "${COLOR_YELLOW}Controllable:${COLOR_RESET} Servers from .mcp.json files"
    echo -e "${COLOR_YELLOW}Migration:${COLOR_RESET} Direct servers (from ~/.claude.json) can be migrated"
    echo ""

    # Count servers by scope
    local total_count=0
    local enabled_count=0
    local local_count=0
    local project_count=0
    local user_count=0

    if [[ -f "$STATE_FILE" ]] && [[ -s "$STATE_FILE" ]]; then
        total_count=$(wc -l < "$STATE_FILE")
        enabled_count=$(grep -c '^on:' "$STATE_FILE" || echo "0")
        local_count=$(grep -c ':local:' "$STATE_FILE" || echo "0")
        project_count=$(grep -c ':project:' "$STATE_FILE" || echo "0")
        user_count=$(grep -c ':user:' "$STATE_FILE" || echo "0")
    fi

    echo -e "${COLOR_CYAN}${total_count} total${COLOR_RESET}  │  ${COLOR_GREEN}${enabled_count} enabled${COLOR_RESET}  │  ${COLOR_BLUE}${local_count} local, ${project_count} project, ${user_count} user${COLOR_RESET}"
    echo ""

    # Run fzf with dynamic bindings
    set +e  # Don't exit on fzf cancel

    generate_fzf_list | fzf \
        --ansi \
        --multi \
        --reverse \
        --height=80% \
        --border=rounded \
        --prompt="Filter: " \
        --pointer="▶" \
        --marker="→" \
        --header="[SPACE] Toggle | [ENTER] Save & Exit | [ESC] Cancel
[Ctrl-A] Add Server | [Ctrl-X] Remove Server
[Alt-E] Enable All | [Alt-D] Disable All" \
        --preview="generate_preview {}" \
        --preview-window="right:50%:wrap" \
        --bind="space:execute(toggle_server {})+reload(generate_fzf_list)+refresh-preview" \
        --bind="alt-e:execute-silent(enable_all_servers)+reload(generate_fzf_list)+refresh-preview" \
        --bind="alt-d:execute-silent(disable_all_servers)+reload(generate_fzf_list)+refresh-preview" \
        --bind="ctrl-a:execute(add_server_flow)+reload(generate_fzf_list)+refresh-preview" \
        --bind="ctrl-x:execute(remove_server_flow {})+reload(generate_fzf_list)+refresh-preview" \
        --bind="enter:accept" \
        --bind="esc:abort" \
        --color="fg:#d0d0d0,bg:#121212,hl:#5fff87" \
        --color="fg+:#ffffff,bg+:#262626,hl+:#ffff00" \
        --color="info:#af87ff,prompt:#5fff87,pointer:#ff87d7" \
        --color="marker:#00ff00,spinner:#ff87d7,header:#87afaf" \
        > /dev/null

    local fzf_exit=$?
    set -e

    # Handle exit code
    if [[ $fzf_exit -eq 130 ]] || [[ $fzf_exit -eq 1 ]]; then
        # User cancelled (ESC or Ctrl-C)
        clear
        msg_warning "Cancelled - no changes saved"
        return 1
    elif [[ $fzf_exit -eq 0 ]]; then
        # User confirmed
        clear
        msg_success "Saving changes..."
        save_state_to_settings

        # Show summary
        local new_enabled_count
        new_enabled_count=$(grep -c '^on:' "$STATE_FILE" || echo "0")

        echo ""
        if [[ $new_enabled_count -eq 0 ]]; then
            msg_warning "No servers enabled"
        else
            echo -e "${COLOR_CYAN}Enabled servers (${new_enabled_count}):${COLOR_RESET}"
            while IFS=: read -r state server scope file source_type; do
                if [[ "$state" == "on" ]]; then
                    local dim='\033[2m'
                    echo -e "  ${COLOR_GREEN}${MARK_SUCCESS}${COLOR_RESET} $server ${dim}($scope, $source_type)${COLOR_RESET}"
                fi
            done < "$STATE_FILE"
        fi

        echo ""
        return 0
    else
        msg_error "Unexpected error (exit code: $fzf_exit)"
        return 1
    fi
}

# ============================================================================
# MAIN FUNCTION
# ============================================================================

main() {
    # Set up cleanup trap for state file
    STATE_FILE=$(mktemp)
    trap 'rm -f "$STATE_FILE"' EXIT

    # Check dependencies
    check_dependencies

    # Discover settings file (may trigger new project flow)
    discover_settings_file

    # Load servers into state file
    load_servers

    # Launch TUI
    if launch_fzf_tui; then
        # Success - launch Claude (unless in test mode)
        if [[ -n "${TEST_MODE:-}" ]]; then
            msg_success "Test mode - skipping Claude launch"
            exit 0
        fi

        msg_info "Launching Claude..."
        sleep 0.5

        # Find claude binary
        local claude_bin
        if [[ -L "$HOME/.local/bin/claude" ]]; then
            claude_bin=$(realpath_portable "$HOME/.local/bin/claude")
        elif command -v claude &> /dev/null; then
            claude_bin=$(command -v claude)
        else
            msg_error "Cannot find claude binary"
            exit 1
        fi

        exec "$claude_bin" "$@"
    else
        # User cancelled
        exit 0
    fi
}

# ============================================================================
# ENTRY POINT
# ============================================================================

main "$@"
