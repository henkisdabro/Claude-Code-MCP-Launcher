#!/usr/bin/env bash

# MCP Server Selector v2.0
# Production-grade TUI for managing Claude Code MCP servers
# Cross-platform (Linux/macOS) - Never modifies global config

set -euo pipefail

# ============================================================================
# CONSTANTS & GLOBALS
# ============================================================================

readonly SCRIPT_NAME="$(basename "$0")"
readonly VERSION="2.0.0"

# Color codes
readonly COLOR_RESET='\033[0m'
readonly COLOR_RED='\033[0;31m'
readonly COLOR_GREEN='\033[0;32m'
readonly COLOR_YELLOW='\033[1;33m'
readonly COLOR_BLUE='\033[0;34m'
readonly COLOR_CYAN='\033[0;36m'
readonly COLOR_WHITE='\033[1m'

# Markers
readonly MARK_ERROR="✗"
readonly MARK_SUCCESS="✓"
readonly MARK_WARNING="⚠"
readonly MARK_INFO="→"

# State file (created in main, cleaned up via trap)
STATE_FILE=""

# Settings file path (determined during discovery)
SETTINGS_FILE_PATH=""
SETTINGS_SCOPE=""

# ============================================================================
# UTILITY FUNCTIONS
# ============================================================================

# Portable realpath implementation (works on Linux + macOS)
# Args: $1 - path to resolve
# Returns: absolute path
realpath_portable() {
    local path="$1"

    if [[ -d "$path" ]]; then
        (cd "$path" && pwd)
    elif [[ -e "$path" ]]; then
        local dir=$(dirname "$path")
        local base=$(basename "$path")
        (cd "$dir" && echo "$(pwd)/$base")
    else
        echo "$path"
    fi
}

# Detect operating system
# Returns: "Linux" or "Darwin" or "Unknown"
detect_os() {
    local os
    os=$(uname -s)
    echo "$os"
}

# Messaging utilities
msg_info() {
    echo -e "${COLOR_CYAN}${MARK_INFO}${COLOR_RESET} $*"
}

msg_success() {
    echo -e "${COLOR_GREEN}${MARK_SUCCESS}${COLOR_RESET} $*"
}

msg_error() {
    echo -e "${COLOR_RED}${MARK_ERROR}${COLOR_RESET} $*" >&2
}

msg_warning() {
    echo -e "${COLOR_YELLOW}${MARK_WARNING}${COLOR_RESET} $*"
}

msg_header() {
    echo -e "${COLOR_WHITE}${COLOR_CYAN}$*${COLOR_RESET}"
}

# ============================================================================
# DEPENDENCY CHECKING
# ============================================================================

# Check for required dependencies (fzf, jq)
# Exits with error if missing, provides OS-specific installation instructions
check_dependencies() {
    local missing_deps=()

    for cmd in fzf jq; do
        if ! command -v "$cmd" &> /dev/null; then
            missing_deps+=("$cmd")
        fi
    done

    if [[ ${#missing_deps[@]} -eq 0 ]]; then
        return 0
    fi

    msg_error "Missing required dependencies: ${missing_deps[*]}"
    echo ""

    local os
    os=$(detect_os)

    case "$os" in
        Linux)
            # Detect Linux package manager
            if command -v apt &> /dev/null; then
                echo -e "${COLOR_CYAN}Install with:${COLOR_RESET}"
                echo "  sudo apt update && sudo apt install ${missing_deps[*]}"
            elif command -v dnf &> /dev/null; then
                echo -e "${COLOR_CYAN}Install with:${COLOR_RESET}"
                echo "  sudo dnf install ${missing_deps[*]}"
            elif command -v yum &> /dev/null; then
                echo -e "${COLOR_CYAN}Install with:${COLOR_RESET}"
                echo "  sudo yum install ${missing_deps[*]}"
            elif command -v pacman &> /dev/null; then
                echo -e "${COLOR_CYAN}Install with:${COLOR_RESET}"
                echo "  sudo pacman -S ${missing_deps[*]}"
            else
                echo -e "${COLOR_CYAN}Install using your system's package manager${COLOR_RESET}"
            fi
            ;;
        Darwin)
            if command -v brew &> /dev/null; then
                echo -e "${COLOR_CYAN}Install with:${COLOR_RESET}"
                echo "  brew install ${missing_deps[*]}"
            else
                echo -e "${COLOR_CYAN}Install Homebrew first:${COLOR_RESET}"
                echo "  /bin/bash -c \"\$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)\""
                echo ""
                echo -e "${COLOR_CYAN}Then install dependencies:${COLOR_RESET}"
                echo "  brew install ${missing_deps[*]}"
            fi
            ;;
        *)
            echo -e "${COLOR_CYAN}Please install: ${missing_deps[*]}${COLOR_RESET}"
            ;;
    esac

    exit 1
}

# ============================================================================
# CONFIGURATION DISCOVERY & NEW PROJECT FLOW
# ============================================================================

# Discover settings file with priority order:
# 1. ./.claude/settings.local.json (local override)
# 2. ./.claude/settings.json (legacy local)
# 3. New project flow (if global exists)
# Sets global variables: SETTINGS_FILE_PATH, SETTINGS_SCOPE
discover_settings_file() {
    local current_dir
    current_dir=$(pwd)

    # Priority 1: Local override
    if [[ -f "$current_dir/.claude/settings.local.json" ]]; then
        SETTINGS_FILE_PATH="$current_dir/.claude/settings.local.json"
        SETTINGS_SCOPE="project (local)"
        return 0
    fi

    # Priority 2: Legacy local
    if [[ -f "$current_dir/.claude/settings.json" ]]; then
        SETTINGS_FILE_PATH="$current_dir/.claude/settings.json"
        SETTINGS_SCOPE="project"
        return 0
    fi

    # Priority 3: Check if global exists, trigger new project flow
    if [[ -f "$HOME/.claude/settings.json" ]]; then
        handle_new_project_prompt
        return $?
    fi

    # No configuration found anywhere
    msg_error "No local or global Claude configuration found"
    echo ""
    echo "Please configure Claude first by running 'claude' once."
    exit 1
}

# Handle new project initialization flow
# Prompts user to create local config or use global
handle_new_project_prompt() {
    clear
    msg_header "New Project Detected"
    echo ""
    echo "You are in a directory without a local Claude configuration."
    echo "The global configuration will be used as a template."
    echo ""
    echo "What would you like to do?"
    echo ""
    echo "  ${COLOR_GREEN}1)${COLOR_RESET} Create a new local configuration (.claude/settings.local.json) for this project ${COLOR_CYAN}(Recommended)${COLOR_RESET}"
    echo "  ${COLOR_YELLOW}2)${COLOR_RESET} Use global settings for this command only (no changes will be saved)"
    echo "  ${COLOR_RED}3)${COLOR_RESET} Abort"
    echo ""

    local choice
    read -rp "Enter your choice [1-3]: " choice

    case "$choice" in
        1)
            # Create local config
            msg_info "Creating local configuration..."
            mkdir -p ./.claude
            cp "$HOME/.claude/settings.json" "./.claude/settings.local.json"
            SETTINGS_FILE_PATH="./.claude/settings.local.json"
            SETTINGS_SCOPE="project (local)"
            msg_success "Created ./.claude/settings.local.json"
            echo ""
            return 0
            ;;
        2)
            # Use global, skip TUI
            msg_info "Using global settings for this session..."
            echo ""
            # Find the real claude binary
            local claude_bin
            if [[ -L "$HOME/.local/bin/claude" ]]; then
                claude_bin=$(realpath_portable "$HOME/.local/bin/claude")
            elif command -v claude &> /dev/null; then
                claude_bin=$(command -v claude)
            else
                msg_error "Cannot find claude binary"
                exit 1
            fi
            exec "$claude_bin" "$@"
            ;;
        3|*)
            # Abort
            msg_warning "Operation cancelled"
            exit 0
            ;;
    esac
}

# ============================================================================
# STATE MANAGEMENT
# ============================================================================

# Load servers from settings file into state file
# State format: "on:server-name" or "off:server-name" (one per line)
load_servers() {
    # Validate JSON first
    if ! jq empty "$SETTINGS_FILE_PATH" 2>/dev/null; then
        msg_error "Settings file is malformed JSON: $SETTINGS_FILE_PATH"
        exit 1
    fi

    # Read enabled and disabled arrays
    local enabled
    local disabled
    enabled=$(jq -r '.enabledMcpjsonServers[]? // empty' "$SETTINGS_FILE_PATH" 2>/dev/null | sort -u)
    disabled=$(jq -r '.disabledMcpjsonServers[]? // empty' "$SETTINGS_FILE_PATH" 2>/dev/null | sort -u)

    # Get all unique servers
    local all_servers
    all_servers=$(printf "%s\n%s" "$enabled" "$disabled" | sort -u | grep -v '^$' || true)

    if [[ -z "$all_servers" ]]; then
        msg_warning "No MCP servers found in configuration"
        echo ""
        msg_info "You can add servers using Ctrl-A in the TUI"
        echo ""
        # Create empty state file
        touch "$STATE_FILE"
        return 0
    fi

    # Build state file
    > "$STATE_FILE"  # Truncate
    while IFS= read -r server; do
        if [[ -n "$enabled" ]] && echo "$enabled" | grep -q "^${server}$"; then
            echo "on:$server" >> "$STATE_FILE"
        else
            echo "off:$server" >> "$STATE_FILE"
        fi
    done <<< "$all_servers"
}

# Toggle server state in state file
# Args: $1 - server name (may have prefix like "[ON ] server-name")
toggle_server() {
    local raw_input="$1"

    # Strip ANSI codes and prefixes to get clean server name
    local server
    server=$(echo "$raw_input" | sed 's/\x1b\[[0-9;]*m//g' | sed 's/^\[ON \] *//' | sed 's/^\[OFF\] *//' | sed 's/^     *//')

    # Read state file, toggle the server, write back
    local temp_state
    temp_state=$(mktemp)

    while IFS= read -r line; do
        if [[ "$line" == "on:$server" ]]; then
            echo "off:$server" >> "$temp_state"
        elif [[ "$line" == "off:$server" ]]; then
            echo "on:$server" >> "$temp_state"
        else
            echo "$line" >> "$temp_state"
        fi
    done < "$STATE_FILE"

    mv "$temp_state" "$STATE_FILE"
}

# Add new server to state file (disabled by default)
# Args: $1 - server name
add_server() {
    local server="$1"

    # Validate server name (alphanumeric, dashes, underscores)
    if [[ ! "$server" =~ ^[a-zA-Z0-9_-]+$ ]]; then
        msg_error "Invalid server name. Use only alphanumeric characters, dashes, and underscores."
        return 1
    fi

    # Check for duplicates
    if grep -q ":$server$" "$STATE_FILE" 2>/dev/null; then
        msg_warning "Server '$server' already exists"
        return 1
    fi

    # Add to state file (disabled)
    echo "off:$server" >> "$STATE_FILE"
    sort -u "$STATE_FILE" -o "$STATE_FILE"
}

# Remove server from state file
# Args: $1 - server name (may have prefix)
remove_server() {
    local raw_input="$1"

    # Strip ANSI codes and prefixes
    local server
    server=$(echo "$raw_input" | sed 's/\x1b\[[0-9;]*m//g' | sed 's/^\[ON \] *//' | sed 's/^\[OFF\] *//' | sed 's/^     *//')

    # Remove from state file
    local temp_state
    temp_state=$(mktemp)

    grep -v ":$server$" "$STATE_FILE" > "$temp_state" || true
    mv "$temp_state" "$STATE_FILE"
}

# Enable all servers in state file
enable_all_servers() {
    local temp_state
    temp_state=$(mktemp)

    sed 's/^off:/on:/' "$STATE_FILE" > "$temp_state"
    mv "$temp_state" "$STATE_FILE"
}

# Disable all servers in state file
disable_all_servers() {
    local temp_state
    temp_state=$(mktemp)

    sed 's/^on:/off:/' "$STATE_FILE" > "$temp_state"
    mv "$temp_state" "$STATE_FILE"
}

# Save state file back to settings.json atomically
save_state_to_settings() {
    # Parse state file into enabled and disabled arrays
    local enabled_servers=()
    local disabled_servers=()

    while IFS= read -r line; do
        if [[ "$line" == on:* ]]; then
            enabled_servers+=("${line#on:}")
        elif [[ "$line" == off:* ]]; then
            disabled_servers+=("${line#off:}")
        fi
    done < "$STATE_FILE"

    # Build JSON arrays
    local enabled_json
    local disabled_json

    if [[ ${#enabled_servers[@]} -eq 0 ]]; then
        enabled_json="[]"
    else
        enabled_json=$(printf '%s\n' "${enabled_servers[@]}" | jq -R . | jq -s -c .)
    fi

    if [[ ${#disabled_servers[@]} -eq 0 ]]; then
        disabled_json="[]"
    else
        disabled_json=$(printf '%s\n' "${disabled_servers[@]}" | jq -R . | jq -s -c .)
    fi

    # Atomic update using temp file
    local temp_file
    temp_file=$(mktemp)

    jq --argjson enabled "$enabled_json" \
       --argjson disabled "$disabled_json" \
       '.enabledMcpjsonServers = $enabled | .disabledMcpjsonServers = $disabled' \
       "$SETTINGS_FILE_PATH" > "$temp_file"

    mv "$temp_file" "$SETTINGS_FILE_PATH"
}

# ============================================================================
# TUI GENERATION FUNCTIONS
# ============================================================================

# Generate fzf list from state file
# Output format: "[ON ] server-name" or "[OFF] server-name"
generate_fzf_list() {
    if [[ ! -f "$STATE_FILE" ]] || [[ ! -s "$STATE_FILE" ]]; then
        echo ""
        return
    fi

    while IFS= read -r line; do
        if [[ "$line" == on:* ]]; then
            local server="${line#on:}"
            echo -e "${COLOR_GREEN}[ON ]${COLOR_RESET} $server"
        elif [[ "$line" == off:* ]]; then
            local server="${line#off:}"
            echo -e "${COLOR_RED}[OFF]${COLOR_RESET} $server"
        fi
    done < "$STATE_FILE"
}

# Generate preview for selected server
# Args: $1 - full line from fzf (e.g., "[ON ] server-name")
generate_preview() {
    local raw_input="$1"

    # Strip ANSI codes and prefixes
    local server
    server=$(echo "$raw_input" | sed 's/\x1b\[[0-9;]*m//g' | sed 's/^\[ON \] *//' | sed 's/^\[OFF\] *//' | sed 's/^     *//')

    if [[ -z "$server" ]]; then
        echo "No server selected"
        return
    fi

    # Find current state and pending state
    local current_state="Unknown"
    local pending_state="Unknown"

    if grep -q "^on:$server$" "$STATE_FILE" 2>/dev/null; then
        current_state="${COLOR_GREEN}Enabled${COLOR_RESET}"
        pending_state="${COLOR_GREEN}Enabled${COLOR_RESET}"
    elif grep -q "^off:$server$" "$STATE_FILE" 2>/dev/null; then
        current_state="${COLOR_RED}Disabled${COLOR_RESET}"
        pending_state="${COLOR_RED}Disabled${COLOR_RESET}"
    fi

    echo -e "${COLOR_CYAN}Server:${COLOR_RESET} ${COLOR_WHITE}$server${COLOR_RESET}"
    echo ""
    echo -e "${COLOR_CYAN}Current Status:${COLOR_RESET} $current_state"
    echo -e "${COLOR_CYAN}After Confirm:${COLOR_RESET} $pending_state"
    echo ""
    echo -e "${COLOR_YELLOW}Tip:${COLOR_RESET} Press ${COLOR_CYAN}SPACE${COLOR_RESET} to toggle"
}

# ============================================================================
# SERVER MANAGEMENT FLOWS
# ============================================================================

# Interactive flow to add a new server
add_server_flow() {
    # Redirect to tty to get input from user
    exec < /dev/tty

    echo ""
    echo -e "${COLOR_CYAN}Add New Server${COLOR_RESET}"
    echo ""
    read -rp "Enter server name (or press Enter to cancel): " server_name

    if [[ -z "$server_name" ]]; then
        echo "Cancelled"
        sleep 0.5
        return 0
    fi

    if add_server "$server_name"; then
        msg_success "Added $server_name"
        sleep 0.5
    else
        sleep 1
    fi
}

# Interactive flow to remove a server
# Args: $1 - server line from fzf
remove_server_flow() {
    local raw_input="$1"

    # Strip to get server name
    local server
    server=$(echo "$raw_input" | sed 's/\x1b\[[0-9;]*m//g' | sed 's/^\[ON \] *//' | sed 's/^\[OFF\] *//' | sed 's/^     *//')

    if [[ -z "$server" ]]; then
        return 0
    fi

    # Redirect to tty to get input from user
    exec < /dev/tty

    echo ""
    echo -e "${COLOR_YELLOW}Remove Server: ${COLOR_WHITE}$server${COLOR_RESET}"
    echo ""
    read -rp "Are you sure? (y/N): " confirm

    if [[ "$confirm" =~ ^[Yy]$ ]]; then
        remove_server "$server"
        msg_success "Removed $server"
        sleep 0.5
    else
        echo "Cancelled"
        sleep 0.5
    fi
}

# ============================================================================
# MAIN TUI LAUNCHER
# ============================================================================

# Launch fzf TUI with all bindings and interactions
launch_fzf_tui() {
    # Export functions and variables for fzf subshells
    export STATE_FILE
    export COLOR_RESET COLOR_RED COLOR_GREEN COLOR_YELLOW COLOR_BLUE COLOR_CYAN COLOR_WHITE
    export -f toggle_server generate_fzf_list add_server remove_server
    export -f enable_all_servers disable_all_servers
    export -f add_server_flow remove_server_flow msg_error msg_warning msg_success

    clear
    msg_header "MCP Server Selector v${VERSION}"
    echo -e "${COLOR_YELLOW}Scope:${COLOR_RESET} $SETTINGS_SCOPE"
    echo -e "${COLOR_YELLOW}Config:${COLOR_RESET} $SETTINGS_FILE_PATH"
    echo ""

    # Count servers
    local total_count=0
    local enabled_count=0
    if [[ -f "$STATE_FILE" ]] && [[ -s "$STATE_FILE" ]]; then
        total_count=$(wc -l < "$STATE_FILE")
        enabled_count=$(grep -c '^on:' "$STATE_FILE" || echo "0")
    fi

    echo -e "${COLOR_CYAN}${total_count} total${COLOR_RESET}  │  ${COLOR_GREEN}${enabled_count} enabled${COLOR_RESET}"
    echo ""

    # Run fzf with dynamic bindings
    set +e  # Don't exit on fzf cancel

    generate_fzf_list | fzf \
        --ansi \
        --multi \
        --reverse \
        --height=80% \
        --border=rounded \
        --prompt="Filter: " \
        --pointer="▶" \
        --marker="→" \
        --header="[SPACE] Toggle | [ENTER] Save & Exit | [ESC] Cancel | [Ctrl-A] Add | [Ctrl-X] Remove
[Alt-E] Enable All | [Alt-D] Disable All" \
        --bind="space:execute-silent(toggle_server {})+reload(generate_fzf_list)" \
        --bind="alt-e:execute-silent(enable_all_servers)+reload(generate_fzf_list)" \
        --bind="alt-d:execute-silent(disable_all_servers)+reload(generate_fzf_list)" \
        --bind="ctrl-a:execute(add_server_flow)+reload(generate_fzf_list)" \
        --bind="ctrl-x:execute(remove_server_flow {})+reload(generate_fzf_list)" \
        --bind="enter:accept" \
        --bind="esc:abort" \
        --color="fg:#d0d0d0,bg:#121212,hl:#5fff87" \
        --color="fg+:#ffffff,bg+:#262626,hl+:#ffff00" \
        --color="info:#af87ff,prompt:#5fff87,pointer:#ff87d7" \
        --color="marker:#00ff00,spinner:#ff87d7,header:#87afaf" \
        > /dev/null

    local fzf_exit=$?
    set -e

    # Handle exit code
    if [[ $fzf_exit -eq 130 ]] || [[ $fzf_exit -eq 1 ]]; then
        # User cancelled (ESC or Ctrl-C)
        clear
        msg_warning "Cancelled - no changes saved"
        return 1
    elif [[ $fzf_exit -eq 0 ]]; then
        # User confirmed
        clear
        msg_success "Saving changes..."
        save_state_to_settings

        # Show summary
        local new_enabled_count
        new_enabled_count=$(grep -c '^on:' "$STATE_FILE" || echo "0")

        echo ""
        if [[ $new_enabled_count -eq 0 ]]; then
            msg_warning "No servers enabled"
        else
            echo -e "${COLOR_CYAN}Enabled servers (${new_enabled_count}):${COLOR_RESET}"
            grep '^on:' "$STATE_FILE" | sed 's/^on://' | while read -r srv; do
                echo -e "  ${COLOR_GREEN}${MARK_SUCCESS}${COLOR_RESET} $srv"
            done
        fi

        echo ""
        return 0
    else
        msg_error "Unexpected error (exit code: $fzf_exit)"
        return 1
    fi
}

# ============================================================================
# MAIN FUNCTION
# ============================================================================

main() {
    # Set up cleanup trap for state file
    STATE_FILE=$(mktemp)
    trap 'rm -f "$STATE_FILE"' EXIT

    # Check dependencies
    check_dependencies

    # Discover settings file (may trigger new project flow)
    discover_settings_file

    # Load servers into state file
    load_servers

    # Launch TUI
    if launch_fzf_tui; then
        # Success - launch Claude (unless in test mode)
        if [[ -n "${TEST_MODE:-}" ]]; then
            msg_success "Test mode - skipping Claude launch"
            exit 0
        fi

        msg_info "Launching Claude..."
        sleep 0.5

        # Find claude binary
        local claude_bin
        if [[ -L "$HOME/.local/bin/claude" ]]; then
            claude_bin=$(realpath_portable "$HOME/.local/bin/claude")
        elif command -v claude &> /dev/null; then
            claude_bin=$(command -v claude)
        else
            msg_error "Cannot find claude binary"
            exit 1
        fi

        exec "$claude_bin" "$@"
    else
        # User cancelled
        exit 0
    fi
}

# ============================================================================
# ENTRY POINT
# ============================================================================

main "$@"
